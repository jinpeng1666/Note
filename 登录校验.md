# 案例

## 黑马点评



## emall



## hmall

[Note/微服务笔记.md at main · jinpeng1666/Note](https://github.com/jinpeng1666/Note/blob/main/微服务笔记.md#网关登录校验)



### JWT



### 过滤器



# 实现技术

## Session

### 介绍

**HttpSession**

`HttpSession` 是 Java Servlet 提供的一个接口，用于在服务端记录用户会话（session）信息。每一个用户在浏览器和服务器之间的交互，都会被服务端创建一个唯一的 `HttpSession` 对象来维护该用户的状态。

当用户第一次访问应用时，服务器会创建一个 `HttpSession` 实例，并分配一个唯一的 `Session ID`。这个 ID 会存储在浏览器的 Cookie 中，并在每次请求时自动发送给服务器，从而保持状态。



**Session ID 是如何返回给前端的？**

在 Web 应用中，**Session 用于保存用户的状态信息**，而前端和服务器之间的状态识别是通过 **Session ID** 实现的

第一次请求时（用户还没有 Session）：

1. 浏览器首次向服务器发起请求（如 `/user/code?phone=...`）
2. 服务器检测到请求中没有携带 `Session ID`，于是自动创建一个新的 `HttpSession` 对象
3. 系统为这个 `HttpSession` 分配一个唯一标识，比如：`JSESSIONID=ABC123XYZ456`
4. 服务器在响应头中添加内容：`Cookie: JSESSIONID=ABC123XYZ456`
5. 浏览器接收响应后，会自动将这个 Cookie（JSESSIONID）保存下来

后续请求时（用户已建立 Session）：

1. 浏览器再次请求服务器（如 `/user/me`），自动携带 Cookie：Cookie: JSESSIONID=ABC123XYZ456
2. 服务器通过这个 ID 获取对应的 `HttpSession`，读取其中保存的信息（如验证码、用户登录状态等）



### 共享问题

![image-20250424224450056](https://raw.githubusercontent.com/jinpeng1666/picgo/master/Typora/other/image-20250424224450056.png)

## JWT

WT 是一个 **字符串令牌**，由三部分组成：

```
复制编辑
xxxxx.yyyyy.zzzzz
```

1. **Header**：令牌头部，标明签名算法
2. **Payload**：有效载荷，通常包含用户 ID、角色、过期时间等信息
3. **Signature**：签名部分，防篡改（用密钥+前两部分生成的）

**验证流程**：

- 后端收到 JWT → 拿出 Header 和 Payload → 用秘钥计算签名 → 对比 JWT 的签名部分 → 签名一致即有效



**优点**

- 无需服务器存储状态，天生支持分布式

- 跨服务间传递用户信息方便（比如 OAuth、微服务）

- 灵活自定义 Payload（如角色、权限等）

**缺点**

- **无法主动失效**：即使用户退出登录，JWT 仍可被用到过期

- **泄露风险高**：一旦被截获，除非过期，服务端无法拦截

- **内容暴露**：Payload 是 Base64 编码的，任何人都能看到里面的内容（敏感信息需加密）



## JWT 和 Session ID 的联系

- Session 是“服务器存”，JWT 是“客户端存”
- 都是用来“识别当前用户”的方式
- 都可用于实现登录态管理
- 浏览器端通常都用 Cookie 或 LocalStorage 保存它们
- 发送请求时，后端通过解析这些“令牌”来识别用户身份



## 核心区别

| 对比项           | Session ID                             | JWT（JSON Web Token）                              |
| ---------------- | -------------------------------------- | -------------------------------------------------- |
| **存储位置**     | 服务端（Session 保存在内存、Redis 等） | 客户端（JWT 保存在 Cookie 或 LocalStorage）        |
| **身份验证过程** | 查找 Session（通过 Session ID）        | 验签 JWT 自身是否有效                              |
| **服务端状态**   | 有状态（需记录每个用户的 Session）     | 无状态（不记录状态，完全靠 JWT 自身的信息）        |
| **扩展性**       | 多节点需共享 Session（如 Redis）       | 天生支持分布式，节点无状态                         |
| **安全性**       | Session ID 若被盗用可伪装用户          | JWT 若泄露也能伪装用户，但无法销毁（除非设置过期） |
| **大小和开销**   | 小（只传一个 Session ID）              | 相对较大（JWT 是完整数据包 + 签名）                |
| **登出控制**     | 可以立即销毁 Session                   | 无法主动注销 JWT（只能等它过期）                   |



# 图

## hmall

### 流程图

```mermaid
graph TD
    classDef startend fill:#F5EBFF,stroke:#BE8FED,stroke-width:2px;
    classDef process fill:#E5F6FF,stroke:#73A6FF,stroke-width:2px;
    classDef decision fill:#FFF6CC,stroke:#FFBC52,stroke-width:2px;
    
    A([开始]):::startend --> B(前端收集用户名和密码):::process
    B --> C(前端发送登录请求):::process
    C --> D(网关):::process
    D --> E{是否为放行路径?}:::decision
    E -- 是 --> F(直接放行到对应服务):::process
    E -- 否 --> G(全局过滤器 GlobalFilter):::process
    G --> H(从请求头获取 Token):::process
    H --> I{Token 是否存在?}:::decision
    I -- 否 --> J(返回 401 未授权):::process
    I -- 是 --> K(JWT 工具 - 校验并解析 Token):::process
    K --> L{Token 格式是否正确?}:::decision
    L -- 否 --> J
    L -- 是 --> M{Token 是否有效?}:::decision
    M -- 否 --> J
    M -- 是 --> N{Token 是否过期?}:::decision
    N -- 是 --> J
    N -- 否 --> O(解析 Token 获取用户 ID):::process
    O --> P(将用户 ID 放入请求头):::process
    P --> Q(放行到对应微服务，如 item-service):::process
    F --> R(微服务处理请求):::process
    Q --> R
    R --> S{是否为登录请求?}:::decision
    S -- 是 --> T(用户服务 UserService):::process
    T --> U(验证用户名和密码):::process
    U --> V{验证是否通过?}:::decision
    V -- 否 --> W(返回登录失败信息):::process
    V -- 是 --> X(JWT 工具 - 生成 Token):::process
    X --> Y(设置 Token 有效期):::process
    Y --> Z(封装用户信息和 Token 返回给前端):::process
    S -- 否 --> AA(正常处理业务逻辑):::process
    W --> AB([结束]):::startend
    Z --> AB
    AA --> AB
    J --> AB
```

### 时序图


```mermaid
sequenceDiagram
    participant 前端
    participant 网关
    participant 全局过滤器
    participant 用户控制器
    participant 用户服务层
    participant 用户数据访问层
    participant JWT工具类
    
    前端 ->> 网关: 发送登录请求（用户名, 密码）
    网关 ->> 全局过滤器: 传递请求
    全局过滤器 ->> 全局过滤器: 从请求头获取 Token
    alt Token 为空
        全局过滤器 ->> 前端: 返回 401 未授权
    else Token 存在
        全局过滤器 ->> JWT工具类: 调用 parseToken 方法解析 Token
        alt Token 无效
            JWT工具类 ->> 全局过滤器: 抛出 UnauthorizedException
            全局过滤器 ->> 前端: 返回 401 未授权
        else Token 有效
            全局过滤器 ->> 用户控制器: 放行请求
            用户控制器 ->> 用户服务层: 调用 login 方法（LoginFormDTO）
            用户服务层 ->> 用户数据访问层: 根据用户名查询用户
            alt 用户不存在
                用户数据访问层 ->> 用户服务层: 返回 null
                用户服务层 ->> 用户控制器: 抛出 BadRequestException（用户名错误）
                用户控制器 ->> 前端: 返回用户名错误
            else 用户存在
                用户数据访问层 ->> 用户服务层: 返回用户信息
                用户服务层 ->> 用户服务层: 校验用户是否被冻结
                alt 用户被冻结
                    用户服务层 ->> 用户控制器: 抛出 ForbiddenException（用户被冻结）
                    用户控制器 ->> 前端: 返回用户被冻结
                else 用户未被冻结
                    用户服务层 ->> 用户服务层: 校验密码
                    alt 密码错误
                        用户服务层 ->> 用户控制器: 抛出 BadRequestException（用户名或密码错误）
                        用户控制器 ->> 前端: 返回用户名或密码错误
                    else 密码正确
                        用户服务层 ->> JWT工具类: 调用 createToken 方法（用户ID, 有效期）
                        JWT工具类 ->> 用户服务层: 返回 Token
                        用户服务层 ->> 用户服务层: 封装 UserLoginVO（用户ID, 用户名, 余额, Token）
                        用户服务层 ->> 用户控制器: 返回 UserLoginVO
                        用户控制器 ->> 前端: 返回登录成功信息和 Token
                    end
                end
            end
        end
    end
```

