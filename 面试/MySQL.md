# 1- SQL 基础

## 1-1- NOSQL 和 SQL 的区别

==定义 -> 存储内容的格式 -> ACID==

- SQL数据库：
    - 指关系型数据库，主要代表：MySQL和Oracle等
    - 关系型数据库存储<font color='red'>结构化数据</font>。这些数据逻辑上以<font color='red'>行列二维表</font>的形式存在，每一<font color='red'>列</font>代表数据的一种属性，每一<font color='red'>行</font>代表一个数据实体
    - 关系型数据库支持 <font color='red'>ACID</font> 即原子性，一致性，隔离性和持续性
- NoSQL数据库：
    - 指非关系型数据库，主要代表：MongoDB和Redis等
    - 非关系型数据库逻辑上提供了<font color='red'>不同于二维表</font>的存储方式，存储方式可以是JSON文档、哈希表或者其他方式
    - NoSQL 采用更宽松的模型 <font color='red'>BASE</font> ， 即基本可用，软状态和最终一致性



## 1-2-数据库的三大范式是什么

==三大范式的目的 -> 每一个范式是什么==

目的：数据库范式是设计关系型数据库时遵循的规范化原则，旨在<font color='red'>减少数据冗余</font>和<font color='red'>提高数据一致性</font>，三大范式是最基本的规范化要求

- 第一范式：要求数据库表的每一<font color='red'>列</font>都是不可分割的原子数据项
- 第二范式：
    - 在第一范式的基础上，<font color='red'>非码属性必须完全依赖于候选码</font>。解决的是"<font color='red'>部分依赖</font>"问题，当主键由多个列组成时，确保非主键列依赖于整个主键，而不是只依赖主键的一部分
    - 只有当你的表有<font color='red'>复合主键</font>(由多个列组成的主键)时，才需要检查是否违反第二范式；如果主键是单列的(如自增ID)，那么只要满足第一范式，自动就满足第二范式
- 第三范式：需要确保数据表中的<font color='red'>每一列数据都和主键直接相关</font>，而不能间接相关。解决的是"<font color='red'>传递依赖</font>"问题，确保非主键列直接依赖于主键，而不是通过其他非主键列间接依赖主键



## 1-3- MySQL 怎么联表查询（连接类型有哪些）

- 四种标准连接类型：
    - 内连接（INNER JOIN）：内连接返回两个表中有匹配关系的行，获取的是交集部分
    - 左外连接（LEFT JOIN）：左外连接返回左表中的所有行，包括在右表中没有匹配的行。未匹配的右表列会包含NULL
    - 右外连接（RIGHT JOIN）：右外连接返回右表中的所有行，即使左表中没有匹配的行。未匹配的左表列会包含NULL
    - 全外连接（FULL JOIN）：全外连接返回两个表中所有行，包括非匹配行（无匹配时对应侧显示 NULL），在MySQL中，FULL JOIN 需要使用 UNION 来实现，因为 MySQL 不直接支持 FULL JOIN
- 特殊连接类型：
    - 交叉连接（CROSS JOIN）/krɒs/：产生两表的笛卡尔积，返回所有的结果行数 = 表A行数 * 表B行数，特点是无连接条件

![image-20250612100249749](https://picgo-zjp.oss-cn-shenzhen.aliyuncs.com/image-20250612100249749.png)



## 1-4- MySQL 如何避免重复插入数据（避免出现报错）

==做法（约束和insert语句） -> 如何选择那个做法==

1）使用UNIQUE约束

在表的相关列上添加UNIQUE<font color='red'>约束</font>，确保每个值在该列中唯一。如果尝试重复插入数据，MySQL就会返回错误

2）使用`INSERT ... ON DUPLICATE KEY UPDATE`

该语句允许在插入记录时处理重复键的情况。如果插入的记录与现有记录冲突，可以选择<font color='red'>更新</font>现有记录

3）使用`INSERT IGNORE`

该语句会在插入记录时<font color='red'>忽略</font>那些因重复键而导致的插入错误



选择哪种方法取决于具体的需求：

- 如果<font color='red'>需要保证全局唯一性</font>，使用UNIQUE约束是最佳做法
- 如果需要<font color='red'>插入和更新结合</font>可以使用`ON DUPLICATE KEY UPDATE`
- 对于<font color='red'>快速忽略重复插入</font>，`INSERT IGNORE`是合适的选择



## 1-5- CHAR 与 VARCHAR 的区别

==定义（长度是否可变、定义时、使用时） -> 使用场景==

- CHAR：
    - CHAR是<font color='red'>固定长度</font>的字符串类型，定义时需要指定固定长度，存储时会在<font color='red'>末尾补足空格</font>
    - CHAR<font color='red'>适合存储长度固定的数据</font>，如固定长度的代码、状态等，存储空间固定，对于<font color='red'>短字符串</font>效率较高
- VARCHAR：
    - VARCHAR是<font color='red'>可变长度</font>的字符串类型，定义时需要指定最大长度，实际存储时根据实际长度占用存储空间
    - VARCHAR适合存储长度可变的数据，如用户输入的文本、备注等，节约存储空间



## 1-6- VARCHAR括号的数字代表字节还是字符

==回答 -> 举例，引出字符集==

- `VARCHAR` 后面括号里的数字代表的是<font color='red'>字符数</font>，而不是字节数
- 比如 `VARCHAR(10)`，这里的 10 表示该字段最多可以存储 10 个字符。<font color='red'>字符的字节长度取决于所使用的字符集</font>
    - 如果字符集是 ASCII 字符集：ASCII 字符集每个字符占用 1 个字节，那么 VARCHAR(10) 最多可以存储 10 个 ASCII 字符，同时占用的存储空间最多为 10 个字节（不考虑额外的长度记录开销）
    - 如果字符集是 UTF - 8 字符集，它的每个字符可能占用 1 到 4 个字节，对于 `VARCHAR(10)` 的字段，它最多可以存储 10 个字符，但占用的字节数会根据字符的不同而变化



## 1-7- int(1) 和 int(10) 在MySQL有什么不同

==回答 -> 举例==

- `INT(1)` 和 `INT(10)` 的<font color='red'>区别主要在于显示宽度</font>，补零显示
- 比如，字段类型为 `INT(4) ZEROFILL`，实际存入 `5` → 显示为 `0005`，实际存入 `12345` → 显示仍为 `12345`（宽度超限时不截断）



## 1-8- Text 数据类型可以无限大吗

MySQL 3 种text类型的最大长度如下：

- TEXT：65,535 bytes ~64kb
- MEDIUMTEXT：16,777,215 bytes ~16Mb
- LONGTEXT：4,294,967,295 bytes ~4Gb



## 1-9- IP 地址如何在数据库里存储

==IPv4是什么 -> 字符串存储（定义、优缺点） -> 整数类型存储方式（定义、优缺点）==

==优缺点反着来==

- IPv4 地址是一个 <font color='red'>32 位的二进制数</font>，通常以<font color='red'>点分十进制</font>表示法呈现，例如 `192.168.1.1`
- 字符串类型的存储方法：直接将 IP 地址作为字符串存储在数据库中
    - 优点：直观易懂，方便直接进行数据的插入、查询和显示，<font color='red'>不需要进行额外的转换操作</font>
    - 缺点：<font color='red'>占用存储空间</font>较大，字符串比较操作的性能相对较低，不利于进行<font color='red'>范围查询</font>
- 整数类型的存储方法：将 IPv4 地址转换为 <font color='red'>32 位无符号整数</font>进行存储，常用的数据类型有 `INT UNSIGNED`
    - 优点：占用<font color='red'>存储空间</font>小，整数比较操作的性能较高，便于进行<font color='red'>范围查询</font>
    - 缺点：需要进行<font color='red'>额外的转换操作</font>，不够直观，增加了开发的复杂度



## 1-10-说一下外键约束

==作用（表关系、数据完整性一致性）==

外键约束的作用是<font color='red'>维护表与表之间的关系</font>，<font color='red'>确保数据的完整性和一致性</font>



## 1-11- MySQL 的关键字 in 和 exist

==定义（都是用来做什么的，各自的定义） -> 区别（性能、使用场景、null值处理方式）==

- 在MySQL中，`IN` 和 `EXISTS` （/ɪɡˈzɪst/）都是<font color='red'>用来处理子查询的关键词</font>
- `IN`：用于检查左边的表达式<font color='red'>是否存在</font>于右边的列表或子查询的结果集中。如果存在，则`IN` 返回`TRUE`，否则返回`FALSE`
- `EXISTS`：用于判断子查询<font color='red'>是否至少</font>能返回一行数据。它不关心子查询返回什么数据，只关心是否有结果。如果子查询有结果，则`EXISTS` 返回`TRUE`，否则返回`FALSE`
- 区别：
    - <font color='red'>性能差异</font>：因为`EXISTS` 一旦找到匹配项就会立即停止查询，而`IN`可能会扫描整个子查询结果集，所以`EXISTS` 的性能优于 `IN`
    - <font color='red'>使用场景</font>：
        - 如果子查询结果集较小且不频繁变动，`IN` 可能更直观易懂
        - 当子查询涉及外部查询的每一行判断，并且子查询的效率较高时，`EXISTS` 更为合适
    - <font color='red'>NULL值处理方式不同</font>：
        - `IN`本质上是一系列<font color='red'>等值比较</font>，如果子查询结果包含NULL值，`IN`不会匹配NULL
        - `EXISTS` 不受子查询结果中NULL值的影响，因为它关注的是行的存在性，而不是具体值，即使子查询返回的行中包含NULL值，只要返回了行，`EXISTS`就为TRUE



## 1-12- MySQL 中的一些基本函数，你知道哪些

==字符串函数（长度、合并、截取、替换） -> 数值函数（绝对值、幂次方） -> 日期和时间函数（返回日期和时间函数） -> 聚合函数（统计、求和、平均值、最大（小）值==

- 字符串函数
    - `CONCAT(str1, str2, ...)`：连接多个字符串，返回一个合并后的字符串
    - `LENGTH(str)`：返回字符串的长度（字符数）
    - `SUBSTRING(str, pos, len)`：从指定位置开始，截取指定长度的子字符串
    - `REPLACE(str, from_str, to_str)`：将字符串中的某部分替换为另一个字符串
- 数值函数
    - `ABS(num)`：返回数字的绝对值
    - `POWER(num, exponent)`：返回指定数字的指定幂次方
- 日期和时间函数
    - `NOW()`：返回当前日期和时间
    - `CURDATE()`：返回当前日期
- 聚合函数
    - `COUNT(column)`：计算指定列中的非NULL值的个数
    - `SUM(column)`：计算指定列的总和
    - `AVG(column)`：计算指定列的平均值
    - `MAX(column)`：返回指定列的最大值
    - `MIN(column)`：返回指定列的最小值



## 1-13- SQL 查询语句的执行顺序是怎样的

==SQL关键字的编写顺序 -> SQL执行顺序==

![image-20250612111009062](https://picgo-zjp.oss-cn-shenzhen.aliyuncs.com/image-20250612111009062.png)

![image-20250416140423778](https://picgo-zjp.oss-cn-shenzhen.aliyuncs.com/image-20250416140423778.png)



# 2-索引

## 2-1-什么是索引

==定义 -> 好处作用（检索效率和数据排序）==

- 索引（index）是帮助MySQL高效获取数据的数据结构(有序)
- 主要用来提高数据<font color='red'>检索效率</font>，降低数据库的I/O成本同时，索引列可以对数据进行排序，降低<font color="red">数据排序</font>的成本，也能减少CPU的消耗



## 2-2-索引有哪些（索引的分类）

==数据结构 -> 物理存储 -> 应用维度==

1. <font color="red">数据结构划分</font>：
    - B + tree 索引：MySQL 里默认和最常用的索引类型
    - 哈希索引：类似键值对的形式，一次即可定位
    - 全文索引：对文本的内容进行分词，进行搜索
2. <font color="red">物理存储划分</font>：
    - 聚簇索引（聚集索引）：索引结构和数据一起存放的索引
    - 非聚簇索引（非聚集索引）：索引结构和数据分开存放的索引
3. <font color="red">应用维度划分</font>：
    - 主键索引：加速查询 + 列值唯一（不可以有 NULL）+ 表中只有一个
    - 唯一索引：加速查询 + 列值唯一（可以有 NULL）
    - 普通索引：仅加速查询
    - 联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并
    - 覆盖索引：一个索引包含（或者说覆盖）所有需要查询的字段的值
    - 全文索引：对文本的内容进行分词，进行搜索。目前只有 `CHAR`、`VARCHAR`、`TEXT` 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替
    - 前缀索引：对文本的前几个字符创建索引，相比普通索引建立的数据更小，因为只取前几个字符



### 2-2-1-什么是聚集索引和非聚集索引（区别是什么）

==按照什么划分 -> 区别（数据存储、数量、查询效率） -> 选取规则==

- 在InnoDB存储引擎中，聚集索引和非聚集索引是根据<font color="red">索引的存储形式</font>来划分的
- 区别：
    - <font color="red">数据存储</font>：在聚簇索引中，数据和索引存储在叶子节点的；在非聚簇索引中，叶子节点存放的是主键值
    - <font color="red">数量</font>：聚簇索引有且只有一个；非聚簇索引可以存在多个
    - <font color="red">查询效率</font>：由于数据与索引紧密相连，当通过聚簇索引查找数据时，可以直接从索引中获得数据行，而不需要额外的步骤去查找数据所在的位置；当通过聚簇索引查找数据时，需要进行回表查询
- 聚集索引<font color="red">选取规则</font>：
    - 如果存在主键，主键索引就是聚集索引
    - 如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引
    - 如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引



### 2-2-2-什么是唯一索引

唯一索引（Unique Index）是一种<font color="red">强制索引列中的值唯一</font>的索引类型，用来<font color="red">防止数据库表中的数据出现重复值</font>



### 2-2-3-什么叫覆盖索引

覆盖索引是指在SELECT查询中，返回的列全部能在索引中找到，避免了回表查询，提高了性能。使用覆盖索引可以减少对主键索引的查询次数，提高查询效率



### 2-2-4-什么是联合索引

一个索引<font color="red">同时包含多个列（字段）</font>，在一个索引结构中对多个字段联合排序，从而加速多条件查询

**特点**

- 按“最左前缀”原则生效
- 节省索引空间，提高效率
- 可用于覆盖索引



### 2-2-5-主键索引和唯一索引的区别

- 核心功能：
    - 主键索引用于唯一标识表中的<font color="red">每一行</font>记录
    - 唯一索引用于保证指定<font color="red">列</font>或列组合的值唯一
- <font color="red">聚簇索引</font>：
    - InnoDB存储引擎中默认以主键作为聚簇索引
    - 唯一索引属于非聚簇索引
- 对于<font color="red">NULL</font>处理：
    - 主键索引不能为NULL值，未显式定义时，InnoDB会自动生成6字节ROWID主键
    - 特殊处理NULL值(可存在一个NULL)
- <font color="red">查询性能</font>：
    - 主键索引包含行数据，不需要进行回表查询，查询速度快
    - 唯一索引属于非聚簇索引，可能会进行回表查询，查询速度相对慢



## 2-3-索引的优缺点是什么

==优点（检索速度、有序、唯一性） -> 缺点（维护成本、内存占用）==

- 优点：
    - 使用索引可以大大加快数据的<font color="red">检索速度</font>（大大减少检索的数据量），减少 IO 次数
    - 索引是<font color="red">有序</font>的数据结构，排序成本低，范围查询效率高
    - 通过创建唯一性索引，可以保证数据库表中每一行数据的<font color="red">唯一性</font>
- 缺点：
    - <font color="red">创建和维护</font>索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态地修改，这会降低 SQL 执行效率
    - 索引需要使用物理文件存储，也会耗费一定<font color="red">存储空间</font>



## 2-4-什么是索引下推

索引下推（Index Condition Pushdown，ICP）是MySQL 5.6引入的一种优化查询效率的技术，==它允许存储引擎在索引遍历过程中，执行部分 `WHERE` 字句的判断条件，直接过滤掉不满足条件的记录，从而减少回表次数，提高查询效率==



## 2-5-什么是回表查询

回表查询是指通过二级索引找到对应的主键值，然后再通过主键值查询聚簇索引中对应的整行数据的过程



## 2-6- InnoDB 索引与 MyISAM 索引实现的区别是什么

==索引文件结构 -> 聚簇索引实现 -> 索引性能（查询、插入、空间占用）==

- <font color="red">索引文件结构不同</font>：
    - InnoDB：索引与数据在同一个文件中（`.ibd` 文件）
    - MyISAM：数据（`.MYD`）与索引（`.MYI`）分离存储
- <font color="red">聚簇索引实现不同</font>：
    - InnoDB：主键索引的叶子节点存储完整的行数据记录
    - MyISAM：索引叶子节点存储的是数据文件的物理地址（指针），主键索引和非主键索引结构相同
- <font color="red"> 索引性能</font>：
    - 查询性能：
        - InnoDB主键查询极快（直接访问数据）
        - InnoDB二级索引查询稍慢（需要回表）
        - MyISAM主键和二级索引查询性能相当
    - 插入性能：
        - InnoDB插入可能导致页分裂（维护聚簇索引顺序)
        - MyISAM插入总是追加到数据文件末尾，速度更快
    - 空间占用：
        - InnoDB主键较短时整体空间占用更优
        - MyISAM索引大小固定，不受主键长度影响



## 2-7-聊聊索引的底层数据结构

==不同存储引擎使用不同索引 -> B + 树的定义 -> 相比其他数据结构选择B + 树的原因==

<font color="red">不同存储引擎使用不同索引</font>：

- MySQL的默认存储引擎InnoDB使用的是B+树作为索引的存储结构

- MyISAM引擎使用B+树作为索引，但和InnoDB有所不同

- Memory 引擎使用哈希索引



<font color="red">B+树的定义</font>：

B+树（**B+ Tree**）是一种**多路平衡查找树**，具有以下特点：

- 非叶子节点只存储 key，不存储数据（data）
- 所有叶子节点之间通过链表顺序连接，便于范围查询
- 树是平衡的，从根节点到任意叶子节点路径长度相同



在默认存储引擎中，相比于其他结构（如哈希表、B 树、红黑树等），<font color="red">选择B+树的原因</font>包括：

1. **树的高度更低，查询更快**：B+树的节点对应磁盘中的一个“页”，非叶子节点只存 key 和指针，在相同数据量的情况下，B+树的层级比B树低，查找路径更短，性能更优
2. **更高的磁盘读写效率（IO友好）**：树的层数越低，IO次数就越少，性能就越高
3. **范围查询更高效**：所有数据都集中在叶子节点，并且叶子节点通过双向链表连接，因此可以非常高效地进行范围查询和全表扫描



## 2-8- B+ 树的特点是什么

==自平衡 -> 非叶子节点（存储键值） -> 叶子节点（同一层、链表、存储行数据）==

- <font color="red">自平衡</font>：
    - B+树在插入、删除和更新操作后会自动重新平衡，确保树的高度保持相对稳定，从而保持良好的搜索性能
- 非叶子节点：
    - <font color="red">非叶子节点存储键值</font>：
        - 非叶子节点仅存储键值和指向子节点的指针，不包含数据记录
- 叶子节点：
    - 所有叶子节点都在<font color="red">同一层</font>：
        - 这是B+树的一个重要特性，确保了所有数据项的检索都具有相同的I/O延迟，提高了搜索效率
        - 每个叶子节点都包含指向相邻叶子节点的指针，形成一个链表，由于叶子节点之间的<font color="red">链接</font>，B+树非常适合进行范围查询和排序扫描
    - <font color="red">叶子节点存储数据记录</font>：
        - 与B树不同，B+树的叶子节点存储实际的数据记录或指向数据记录的指针。这意味着每次搜索都会到达叶子节点，才能找到所需数据



## 2-9- B 树和 B+ 树的区别是什么

==存储方法 -> 叶子节点==

- <font color="red">数据存储方式</font>：B 树的所有节点既存放键(key)也存放数据(data)，而 B+ 树只有叶子节点存放 key 和 data，其他内节点只存放 key，相同数据量的情况下，B+树的高度更低，更扁平化，IO次数就越少，所以磁盘读写代价低

- <font color="red">叶子节点</font>：B 树的叶子节点都是独立的；B+ 树的叶子节点之间形成了双向链表，范围查询和排序的效率更高

综上，B+ 树与 B 树相比，具备==更少的 IO 次数、更稳定的查询效率和更适于范围查询==这些优势



## 2-10-索引创建原则有哪些（如何正确使用索引）

==表 -> 字段（条件，字符串和高区分度） -> 索引（联合索引和索引数量）==

1. **大表：**针对于数据量较大（10万+），且查询比较频繁的表建立索引
2. **字段：**针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引
3. **字符串字段：**如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引
4. **高区分度字段：**尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高
5. **联合索引：**尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率
6. **索引数量：**要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率
7. **避免 NULL：**如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询



## 2-11-什么情况下索引会失效

==最左 -> 数据匹配（索引列运算、字符引号、模糊查询） -> OR连接和范围查询 -> 数据分布影响==

- 联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。有索引下推优化
- 当我们在查询条件中对索引列进行表达式计算或者使用函数，也是无法走索引的
- 字符串不加引号，遇到字符串和数字比较的时候，会自动把字符串转为数字（进行隐式类型转换，调用了函数），导致索引失效
- 当我们使用左或者左右模糊匹配的时候，索引会失效
- 在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效
- 数据分布影响，当选择区分度低的索引进行全表扫描时，SQL优化器可能不走索引，导致索引失效



## 2-12-什么是自适应哈希索引

自适应哈希索引是Innodb引擎的一个特殊功能，当它==注意到某些索引值被使用的非常频繁时，会在内存中基于B-Tree索引之上再创建一个哈希索引，这就让B-Tree索引也具有哈希索引的一些优点==，比如快速哈希查找。这是一个完全自动的内部行为，用户无法控制或配置



## 2-13-为什么官方建议使用自增长主键作为索引

==顺序插入 -> 空间==

**✅ 自增主键的优势：**

- <font color="red">顺序插入</font>：新数据始终追加在 B+ 树最右端，避免页分裂
- <font color="red">节省空间</font>：整型主键占用少，B+ 树扇出高、树更矮

**⚠️ 字符串主键的劣势：**

- <font color="red">插入无序</font>：容易在中间插入，导致页分裂、结构碎片
- <font color="red">占用空间大</font>：B+ 树扇出降低，树高增加



## 2-14-使用索引一定能提升效率吗

==数据量少 -> 唯一索引 -> 维护成本==

不一定

- <font color="red">少量数据</font>全表扫描也很快，可以直接获取到全量数据
- <font color="red">唯一索引</font>会影响插入速度，但建议使用
- 索引过多会影响<font color="red">更新、插入和删除数据速度</font>



## 2-15-非聚簇索引为什么不存数据地址值而存储主键

==物理地址 -> 覆盖索引==

- <font color="red">避免物理地址失效（页移动）</font>
    - 如果存物理地址，一旦发生页分裂、页合并或记录移动，地址会失效；那就要更新所有指向旧地址的索引项，维护代价高
    - 主键是逻辑标识，稳定不会变，维护成本更低
- <font color="red">便于构建覆盖索引</font>
    - 非聚簇索引可以存储“主键 + 查询字段”，成为覆盖索引；查询命中覆盖索引时，无需回表，效率更高



## 2-16-一个表有多个索引的时候，能否手动选择使用哪个索引

MySQL会自动选择认为最优的索引，但你也可以通过手动方式影响或指定使用哪个索引



## 2-17-什么字段适合当做主键

==建议（非空且唯一、递增） -> 不建议（业务数据）==

- 字段具有<font color="red">非空且唯一</font>的特性时，适合做主键
- 字段最好的是有<font color="red">递增的趋势</font>，如果字段的值是随机无序的，可能会引发页分裂的问题，造成性能影响。多台服务器需要考虑分布式 id
- <font color="red">不建议用业务数据</font>作为主键，比如会员卡号、订单号、学生号之类的，因为我们无法预测未来会不会因为业务需要，而出现业务字段重复或者重用的情况



## 2-18-性别字段能加索引吗

不建议针对性别字段加索引，索引的创建规则之一就是要<font color="red">选择区分度高</font>的字段建立索引



# 3- SQL 优化

## 3-1-如何定位慢查询

使用<font color="red">运维监控系统</font>（Skywalking等）；如果没有这种监控系统，MySQL本身也提供了<font color="red">慢查询日志</font>功能。可以在MySQL的系统配置文件中开启慢查询日志（默认不开启）（在MySQL的配置文件中配置），并设置SQL执行时间超过多少就记录到日志文件，比如我们之前项目设置的是2秒，超过这个时间的SQL就会记录在日志文件中，我们就可以在那里找到执行慢的SQL



## 3-2- SQL 语句执行很慢，如何分析

如果一条SQL执行很慢，我们通常会使用MySQL的`EXPLAIN`命令来分析这条SQL的执行计划。使用命令，会返回该语句的执行计划，要关注几个字段

- possible_keys 字段表示可能用到的索引
- key 字段表示实际用的索引
- key_len 表示索引的长度
- rows 表示扫描的数据行数
- type 表示数据扫描类型（最慢的是全表扫描和全索引扫描，快一点的是索引范围扫描）
- extra 额外的优化建议（是否使用了覆盖索引，是否使用了临时表保存中间结果，是否进行文件排序）



## 3-3- MySQL 超大分页怎么处理

超大分页通常发生在数据量大的情况下，使用`LIMIT`分页查询且需要排序时效率较低。可以通过==覆盖索引和子查询==来解决。首先查询数据的ID字段进行分页，然后根据ID列表用子查询来过滤只查询这些ID的数据，因为查询ID时使用的是覆盖索引，所以效率可以提升



## 3-4- SQL 的优化经验有哪些

- **表的设计优化**
- **索引优化**
- **SQL语句优化**
- **读写分离**
- **分库分表**



### 3-4-1-表的设计优化

==字段（字段类型和冗余字段） -> 字符串类型 -> 约束==

- <font color="red">字段类型</font>选择合理：根据实际数据选择合适的数值类型（如 `tinyint`, `int`, `bigint`），避免为字段分配不必要的大长度
- <font color="red">字符串类型</font>匹配：
    - `CHAR`：适用于定长数据（如身份证号、手机号等），读取效率高
    - `VARCHAR`：适用于变长数据（如用户名、地址等），节省存储空间
- 拆分<font color="red">冗余字段</font>：遵循数据库设计范式（如第三范式），避免数据冗余和更新异常
- 添加必要<font color="red">约束</font>：如 `NOT NULL`、`DEFAULT`、`UNIQUE`、`CHECK` 等，有助于优化器做出更好判断



### 3-4-2-索引优化

遵循<font color="red">索引创建原则</font>



### 3-4-3- SQL 语句优化

- <font color="red">明确字段名称</font>：避免 `SELECT *`，只查询必要字段，减少 I/O 和网络传输压力
- <font color="red">避免索引失效</font>的写法
- <font color="red">合理使用 JOIN</font>：
    - `INNER JOIN` 优于 `LEFT/RIGHT JOIN`
    - 让小表驱动大表，可提高嵌套循环连接效率
    - 使用 `ON` 条件替代 `WHERE` 后过滤
    
- **`UNION ALL` 优先于 `UNION`**：避免重复数据去重，提高性能
- <font color="red">减少嵌套子查询</font>：能使用 JOIN 的场景不建议用子查询，子查询执行效率通常较低
- **LIMIT + OFFSET** 优化：超大分页应使用 ID 过滤或子查询方式提升性能

> [!NOTE]
>
> 小表驱动大表是什么意思？
>
> - 数据库在做嵌套循环（Nested Loop Join）时，会先扫描驱动表，然后对每条记录去被驱动表中匹配
>
> - 小表驱动大表时，匹配次数更少，效率更高



### 3-4-4-读写分离

通过主从复制实现读写分离：

- 主库负责写操作，从库负责读操作
- 降低主库压力，提高整体系统性能



###  3-4-5-分库分表

**分表**：单表数据量过大时，按时间、范围或哈希方式拆分

**分库**：按业务模块或分区逻辑拆库，提升并发处理能力



# 4-事务

## 4-1-事务的特性是什么

> [!NOTE]
>
> 事务是什么？
>
> 事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败

- 原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败
- 一致性（Consistency）：是指事务操作前和操作后，数据要保持前后一致
- 隔离性（Isolation）：一个事务的执行，不受其他并发事务的影响。每个事务都有一个完整的数据空间，对其他并发事务是隔离的
- 持久性（Durability）：事务提交之后，对于数据的修改是永久的，即便系统故障也不会丢失



## 4-2-并发事务带来哪些问题

并发事务可能导致脏读、不可重复读和幻读。

- 脏读是指一个事务读到了另一个事务未提交的“脏数据”
- 不可重复读是指在一个事务内多次读取同一数据，由于其他事务的修改导致数据不一致
- 幻读是指一个事务读取到了其他事务插入的“幻行”



## 4-3- MySQL 是如何解决并发事务带来的问题

- 锁机制：Mysql提供了多种锁机制来保证数据的一致性，包括行级锁、表级锁、页级锁等。通过锁机制，可以在读写操作时对数据进行加锁，确保同时只有一个操作能够访问或修改数据
- 事务隔离级别：Mysql提供了多种事务隔离级别，包括读未提交、读已提交、可重复读和串行化。通过设置合适的事务隔离级别，可以在多个事务并发执行时，控制事务之间的隔离程度，以避免数据不一致的问题
- MVCC：Mysql使用MVCC来管理并发访问，它通过在数据库中保存不同版本的数据来实现不同事务之间的隔离。在读取数据时，Mysql会根据事务的隔离级别来选择合适的数据版本，从而保证数据的一致性



## 4-4- MySQL 的隔离级别有哪些

1. 未提交读（READ UNCOMMITTED）：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读
2. 读已提交（READ COMMITTED）：允许读取并发事务已经提交的数据，可以阻止脏读，但是不可重复读或幻读仍有可能发生
3. 可重复读（REPEATABLE READ）：默认的隔离级别，对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。但是，InnoDB 实现的 REPEATABLE-READ 隔离级别其实是可以解决幻读问题发生的
4. 串行化（SERIALIZABLE）：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读



## 4-5-可重复读隔离级别下，A事务提交的数据，在B事务能看见吗

可重复读隔离级是由 MVCC（多版本并发控制）实现的，实现的方式是开始事务后（执行 begin 语句后），在执行第一个查询语句后，会创建一个 Read View，后续的查询语句利用这个 <font color="red">Read View</font>，通过这个 Read View 就可以在 undo log 版本链找到事务开始时的数据，所以事务过程中每次查询的数据都是一样的，即使中途有其他事务插入了新纪录，是查询不出来这条数据的



## 4-6-事务中的隔离性是如何保证的

事务的隔离性通过<font color="red">锁和多版本并发控制（MVCC）</font>来保证



## 4-7-串行化隔离级别是通过什么实现的

是通过<font color="red">行级锁</font>来实现的，序列化隔离级别下，普通的select 查询是会对记录加<font color="red"> S 型</font>的 next-key 锁，其他事务就没办法对这些已经加锁的记录进行增删改操作了，从而避免了脏读、不可重复读和幻读现象



## 4-8-MVCC

### 4-8-1-概念

- MVCC 是一种并发控制机制，用于在多个并发事务同时读写数据库时，保持数据的<font color="red">一致性和隔离性</font>
- 通过创建数据的<font color="red">多个版本和使用快照读取</font>来实现并发控制



### 4-8-2-InnoDB 对 MVCC的实现

`MVCC` 的实现<font color="red">依赖</font>于：**隐藏字段、Read View、undo log**。在内部实现中，`InnoDB` 通过数据行的 `DB_TRX_ID` 和 `Read View` 来判断数据的可见性，如不可见，则通过数据行的 `DB_ROLL_PTR` 找到 `undo log` 中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建 `Read View` 之前已经提交的修改和该事务本身做的修改



#### 4-8-1-1-隐藏字段

在内部，`InnoDB` 存储引擎为每行数据添加了三个隐藏字段

- `DB_TRX_ID（6字节）`：表示最后一次插入或更新该行的事务 id。此外，`delete` 操作在内部被视为更新，只不过会在记录头 `Record header` 中的 `deleted_flag` 字段将其标记为已删除
- `DB_ROLL_PTR（7字节）` 回滚指针，指向该行的 `undo log` 。如果该行未被更新，则为空
- `DB_ROW_ID（6字节）`：如果没有设置主键且该表没有唯一非空索引时，`InnoDB` 会使用该 id 来生成聚簇索引



#### 4-8-1-2- Read View

Read View主要是用来做<font color="red">可见性判断</font>，里面保存了 “当前对本事务不可见的其他活跃事务”

主要有以下字段：

- `m_low_limit_id`：目前出现过的最大的事务 ID+1，即下一个将被分配的事务 ID。大于等于这个 ID 的数据版本均不可见
- `m_up_limit_id`：活跃事务列表 `m_ids` 中最小的事务 ID，如果 `m_ids` 为空，则 `m_up_limit_id` 为 `m_low_limit_id`。小于这个 ID 的数据版本均可见
- `m_ids`：`Read View` 创建时其他未提交的活跃事务 ID 列表。创建 `Read View`时，将当前未提交事务 ID 记录下来，后续即使它们修改了记录行的值，对于当前事务也是不可见的。`m_ids` 不包括当前事务自己和已提交的事务（正在内存中）
- `m_creator_trx_id`：创建该 `Read View` 的事务 ID

![image-20250519131058877](https://picgo-zjp.oss-cn-shenzhen.aliyuncs.com/image-20250519131058877.png)



##### 4-8-1-2-1-数据可见性算法

1. 如果记录 DB_TRX_ID < m_up_limit_id，那么表明最新修改该行的事务（DB_TRX_ID）在当前事务创建快照之前就提交了，所以该记录行的值对当前事务是可见的
2. 如果 DB_TRX_ID >= m_low_limit_id，那么表明最新修改该行的事务（DB_TRX_ID）在当前事务创建快照之后才修改该行，所以该记录行的值对当前事务不可见。跳到步骤 5
3. m_ids 为空，则表明在当前事务创建快照之前，修改该行的事务就已经提交了，所以该记录行的值对当前事务是可见的
4. 如果 m_up_limit_id <= DB_TRX_ID < m_low_limit_id，表明最新修改该行的事务（DB_TRX_ID）在当前事务创建快照的时候可能处于“活动状态”或者“已提交状态”；所以就要对活跃事务列表 m_ids 进行查找（源码中是用的二分查找，因为是有序的）
    - 如果在活跃事务列表 m_ids 中能找到 DB_TRX_ID，表明：① 在当前事务创建快照前，该记录行的值被事务 ID 为 DB_TRX_ID 的事务修改了，但没有提交；或者 ② 在当前事务创建快照后，该记录行的值被事务 ID 为 DB_TRX_ID 的事务修改了。这些情况下，这个记录行的值对当前事务都是不可见的。跳到步骤 5
    - 在活跃事务列表中找不到，则表明“id 为 trx_id 的事务”在修改“该记录行的值”后，在“当前事务”创建快照前就已经提交了，所以记录行对当前事务可见
5. 在该记录行的 DB_ROLL_PTR 指针所指向的 `undo log` 取出快照记录，用快照记录的 DB_TRX_ID 跳到步骤 1 重新开始判断，直到找到满足的快照版本或返回空



#### 4-8-1-3-undo log

`undo log` 主要有两个作用：

- 当<font color="red">事务回滚</font>时用于将数据恢复到修改前的样子
- 另一个作用是 <font color="red">`MVCC` </font>，当读取记录时，若该记录被其他事务占用或当前版本对该事务不可见，则可以通过 `undo log` 读取之前的版本数据，以此实现<font color="red">非锁定读</font>



## 4-9- RC 和 RR 隔离级别下 MVCC 的差异

在事务隔离级别 `RC` 和 `RR` （InnoDB 存储引擎的默认事务隔离级别）下，`InnoDB` 存储引擎使用 `MVCC`（非锁定一致性读），但它们<font color="red">生成 `Read View` 的时机却不同</font>

- 在 RC 隔离级别下的<font color="red">每次普通`select` 语句查询</font>前都生成一个`Read View` (m_ids 列表)，解决的是脏读的问题
- 在 RR 隔离级别下只在<font color="red">事务开始</font>后 第一次`select` 数据前生成一个`Read View`（m_ids 列表），不仅解决的脏读的问题，而且还解决了不可重复度的问题



## 4-10- MVCC + Next-key-Lock 防止幻读

`InnoDB`存储引擎在 RR 级别下通过 `MVCC`和 `Next-key Lock` 来解决幻读问题：

1. 执行普通 `select`，此时会以 `MVCC` 快照读的方式读取数据：
    - 在快照读的情况下，RR 隔离级别只会在事务开启后的第一次查询生成 `Read View` ，并使用至事务提交。所以在生成 `Read View` 之后其它事务所做的更新、插入记录版本对当前事务并不可见，实现了可重复读和防止快照读下的 “幻读”
2. 执行 select...for update/lock in share mode、insert、update、delete 等当前读（也称锁定读，会读取的数据加锁）：
    - 在当前读下，读取的都是最新的数据，如果其它事务有插入新的记录，并且刚好在当前事务查询范围内，就会产生幻读！`InnoDB` 使用 Next-key Lock 来防止这种情况。当执行当前读时，会锁定读取到的记录的同时，锁定它们的间隙，防止其它事务在查询范围内插入数据。只要我不让你插入，就不会发生幻读



## 4-11-是否使用过 select for update

==select本身是一个查询语句，查询语句是不会产生冲突的一种行为，一般情况下是没有锁的，用select for update 会让select语句产生一个排它锁(X), 这个锁和update的效果一样，会使两个事务无法同时更新一条记录==

- for update仅适用于InnoDB，且必须在事务块(BEGIN/COMMIT)中才能生效

- 在进行事务操作时，通过“for update”语句，MySQL会对查询结果集中每行数据都添加排他锁，其他线程对该记录的更新与删除操作都会阻塞。排他锁包含行锁、表锁
- InnoDB默认是行级别的锁，在筛选条件中当有明确指定主键或唯一索引列的时候，是行级锁。否则是表级别



# 5-锁

## 5-1-讲一下 MySQL 中有哪些锁

在 MySQL 里，根据加锁的范围，可以分为<font color="red">全局锁、表级锁和行锁</font>三类

- 全局锁：通过`flush tables with read lock`语句会将整个数据库就处于只读状态了，这时其他线程执行以下操作，增删改或者表结构修改都会阻塞。主要用于<font color="red">全库逻辑备份</font>
- 表级锁：
    - 表锁：通过lock tables 语句可以对表加表锁，表锁除了会限制别的线程的读写外，也会限制本线程接下来的读写操作
    - 元数据锁：当我们对数据库表进行操作时，会自动给这个表加上 MDL，对一张表进行 CRUD 操作时，加的是 **MDL 读锁**；对一张表做结构变更操作的时候，加的是 **MDL 写锁**；MDL为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个<font color="red">表结构</font>做了变更
    - 意向锁：当执行插入、更新、删除操作，需要先对表加上「意向独占锁」，然后对该记录加独占锁。意向锁的目的是为了快速判断表里是否有记录被加锁，解决<font color="red">表锁和行锁的冲突</font>
- 行锁：
    - 记录锁：锁住的是一条记录。而且记录锁是有 S 锁和 X 锁之分的，满足读写互斥，写写互斥
    - 间隙锁：只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象
    - 临建锁（Next-Key Lock）：是 Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身



## 5-2-表级锁和行级锁有什么区别

==粒度 -> 并发性能 -> 使用场景==

- 锁的粒度：
    - 表级锁，锁住的是整个表的数据，锁的粒度大
    - 行级锁，锁住的是一整行数据，锁的粒度小
- 并发性能：
    - 表级锁的粒度大，并发性能低
    - 行级锁的粒度小，并发性能高
- 使用场景：
    - 表级锁适合于<font color="red">需要大批量操作表中数据</font>的场景，例如表的重建、大量数据的加载等
    - 行级锁适用于<font color="red">频繁单行操作</font>



## 5-3-什么是共享锁（读锁）和排它锁（写锁/独占锁）

- 共享锁或S锁，其它事务可以继续加共享锁，但不能加排它锁
- 排它锁或X锁，在进行写操作之前要申请并获得，其它事务不能再获得任何锁



## 5-4-什么是意向锁

==分类 -> 意向锁和行锁的关系==

- 分为意向共享锁（IS）和意向排他锁（IX）
- 一个事务对一张表的某行添加共享锁前，必须获得对该表一个IS锁或者优先级更高的锁
- 一个事务对一张表的某行添加排他锁之前，它必须对该表获取一个IX锁

意向锁属于表锁，它不与innodb中的行锁冲突，任意两个意向锁之间也不会产生冲突，但是会与表锁（S锁和X锁）产生冲突



## 5-5-当前读和快照读分别是什么

当前读 ：在锁定读（使用锁隔离事物）的时候读到的是<font color="red">最新</font>版本的数据

快照读：可重复读（repeatable-read）下 mvcc生效读取的是数据的<font color="red">快照</font>，并不是最新版本的数据（未提交事物的数据）



# 6-存储引擎

## 6-1-MySQL 支持哪些存储引擎

| 特点         | InnoDB           | MyISAM | Memory |
| ------------ | ---------------- | ------ | ------ |
| 存储限制     | 64TB             | 有限制 | 有限制 |
| 事务安全     | 支持             | -      | -      |
| 锁机制       | 行锁             | 表锁   | 表锁   |
| B+tree索引   | 支持             | 支持   | 支持   |
| Hash索引     | -                | -      | 支持   |
| 全文索引     | 支持(5.6版本之后 | 支持   | -      |
| 空间使用     | 高               | 低     | N/A    |
| 内存使用     | 高               | 低     | 中等   |
| 批量插入速度 | 低               | 高     | 高     |
| 支持外键     | 支持             | -      | -      |



## 6-2- MySQL 存储引擎架构了解吗

InnoDB引擎结构图，主要分为<font color="red">内存结构和磁盘结构</font>两大部分：

![image-20250510104406387](https://picgo-zjp.oss-cn-shenzhen.aliyuncs.com/image-20250510104406387.png)

- **内存区域**：
    - **Buffer Pool**：在InnoDB访问表记录和索引时会在Buffer Pool的页中缓存，以后使用可以减少磁盘IO操作，提升效率。主要用来缓存热的数据页和索引页
    - **Log Buffer**：用来缓存redo log
    - **Adaptive Hash Index**：自适应哈希索引
    - **Change Buffer**:它是一种应用在非唯一普通索引页（non-unique secondary index page）不在缓冲池中，对页进行了写操作，并不会立刻将磁盘页加载到缓冲池，而仅仅记录缓冲变更（Buffer Changes），等未来数据被读取时，再将数据合并（Merge）恢复到缓冲池中的技术。写缓冲的目的是降低写操作的磁盘IO，提升数据库性能

- **磁盘区域**
    - 表空间：分为系统表空间(MySQL 目录的 ibdata1 文件)，临时表空间，常规表空间，Undo 表空间以及 file-per-table 表空间(MySQL5.7默认打开file_per_table 配置）。系统表空间又包括了InnoDB数据字典，双写缓冲区(Doublewrite Buffer)，修改缓存(Change Buffer），Undo日志等
    - Redo日志：存储的就是 Log Buffer 刷到磁盘的数据



## 6-3-MyISAM 和 InnoDB 的区别是什么

==外键 -> 事务 -> 锁==

| **对比项**     | **MyISAM**                                               | **InnoDB**                                                   |
| -------------- | -------------------------------------------------------- | ------------------------------------------------------------ |
| 外键           | 不支持                                                   | 支持                                                         |
| 事务           | 不支持                                                   | 支持                                                         |
| 行表锁         | 表锁，即使操作一条记录也会锁住整个表，不适合高并发的操作 | 行锁，操作时只锁某一行，不对其它行有影响，适合高并发的操作   |
| 缓存           | 只缓存索引，不缓存真实数据                               | 不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响 |
| 关注点         | 并发查询，节省资源、消耗少、简单业务                     | 并发写、事务、多表关系、更大资源                             |
| 默认安装       | Y                                                        | Y                                                            |
| 默认使用       | N                                                        | Y                                                            |
| 自带系统表使用 | Y                                                        | N                                                            |



# 7-读写分离

## 7-1- MySQL 主从同步（主从复制）原理是什么

MySQL主从复制的核心是二进制日志（Binlog）。步骤如下：

1. 主库在事务提交时，记录数据变更到 <font color="red">Binlog</font>
2. 从库读取主库的 Binlog 并写入<font color="red">中继日志</font>（Relay Log）
3. 从库<font color="red">重做</font>中继日志中的事件，反映到自己的数据中



# 8-内部架构

## 8-1- MySQL 内部支持缓存查询吗

当MySQL接收到客户端的查询SQL之后，仅仅只需要对其进行相应的权限验证之后，就会通过Query Cache来查找结果，甚至都不需要经过Optimizer模块进行执行计划的分析优化，更不需要发生任何存储引擎的交互

mysql5.7支持内部缓存，8.0之后就废弃掉了



## 8-2- MySQL 8为何废弃掉查询缓存

- 缓存是以 key-value 形式保存在内存中的，key 为 SQL 查询语句，value 为 SQL 语句查询的结果，所以SQL必须<font color="red">完全一致</font>才会导致cache命中
- 为了<font color="red">节省内存空间</font>，太大的result set不会被cache (< query_cache_limit)
- MySQL缓存在<font color="red">分库分表</font>环境下是不起作用的
- 在表的<font color="red">结构或数据</font>发生改变时，基于该表相关cache立即全部失效



## 8-3- MySQL 内部有哪些核心模块组成，作用是什么

![image-20250510101324504](https://picgo-zjp.oss-cn-shenzhen.aliyuncs.com/image-20250510101324504.png)

![image-20250510101347162](https://picgo-zjp.oss-cn-shenzhen.aliyuncs.com/image-20250510101347162.png)

连接层、服务层、引擎层和存储层



## 8-4- SQL 语句在 MySQL 中的执行过程

![image-20250510101944685](https://picgo-zjp.oss-cn-shenzhen.aliyuncs.com/image-20250510101944685.png)

![image-20250510102251937](https://picgo-zjp.oss-cn-shenzhen.aliyuncs.com/image-20250510102251937.png)

### 8-4-1- MySQL 基本架构概览

![image-20250519164228047](https://picgo-zjp.oss-cn-shenzhen.aliyuncs.com/image-20250519164228047.png)

- **Server 层**：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 binlog 日志模块

    - **连接器：** 身份认证和权限相关(登录 MySQL 的时候)
    - **查询缓存：** 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）
    - **分析器：** 进行词法分析和语法分析，没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确
    - **优化器：** 按照 MySQL 认为最优的方案去执行
    - **执行器：** 执行语句，然后从存储引擎返回数据

- **存储引擎**：主要负责数据的存储和读取，采用可以替换的插件式架构，支持 InnoDB、MyISAM、Memory 等多个存储引擎，其中 InnoDB 引擎有自有的日志模块 redolog 模块。**现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5 版本开始就被当做默认存储引擎了**

    

### 8-4-2-查询语句

1. 先检查该语句<font color="red">是否有权限</font>，如果没有权限，直接返回错误信息，如果有权限，在 MySQL8.0 版本以前，会先<font color="red">查询缓存</font>，以这条 SQL 语句为 key 在内存中查询是否有结果，如果有直接缓存，如果没有，执行下一步
2. 分析器进行语句解析
    - <font color="red">词法分析</font>，提取 SQL 语句的关键元素，如表名、字段名、关键字等
    - <font color="red">语法分析</font>,判断这个 SQL 语句是否有语法错误，比如关键词是否正确等等，如果检查没问题就执行下一步
3. <font color="red">优化器</font>确定执行方案
    - 根据表的索引、统计信息等生成多种可能的执行计划
    - 根据内部成本估算模型选择一条“成本最小”的执行计划（不一定是最优，但是优化器认为最优的）
    - 执行计划生成后，交由执行器调度执行
4. 进行<font color="red">权限校验</font>，如果没有权限就会返回错误信息，如果有权限就会调用<font color="red">数据库引擎接口</font>，返回引擎的执行结果
    - MySQL 中数据是以页为单位，你查询一条记录，会从硬盘把一页的数据加载出来，加载出来的数据叫数据页，会放入到<font color="red"> `Buffer Pool` </font>中
    - 后续的查询都是先从 `Buffer Pool` 中找，没有命中再去硬盘加载，减少硬盘 IO 开销，提升性能



### 8-4-3-修改语句

1. 先检查该语句<font color="red">是否有权限</font>，如果没有权限，直接返回错误信息；有权限进行下一步操作
2. 分析器进行语句解析
    - <font color="red">词法分析</font>，提取 SQL 语句的关键元素，如表名、字段名、关键字等
    - <font color="red">语法分析</font>,判断这个 SQL 语句是否有语法错误，比如关键词是否正确等等，如果检查没问题就执行下一步
3. <font color="red">优化器</font>确定执行方案
    - 根据表的索引、统计信息等生成多种可能的执行计划
    - 根据内部成本估算模型选择一条“成本最小”的执行计划（不一定是最优，但是优化器认为最优的）
    - 执行计划生成后，交由执行器调度执行
4. 执行器调用<font color="red">数据库引擎接口</font>

    - 数据加载
        - 当执行修改语句时，目标数据页若不在内存中的 `Buffer Pool`，会先从磁盘加载到 `Buffer Pool`
        - 在 `Buffer Pool` 中对数据页进行修改（内存中修改，不是直接改磁盘）
    - 事务执行期间
        - `redo log buffer` 和 `undo log` 由存储引擎持续写入，保证物理数据修改的持久性和可回滚性
        - Server 层将执行的更新语句或对应的行变更操作写入内存中的 `binlog cache`（逻辑日志缓存）
    - 事务提交阶段（刷盘与两阶段提交）
        - 存储引擎根据`redo log`的刷盘策略（事务提交时或者缓存空间不足等），将 `redo log buffer` 中的日志刷盘到磁盘的 `redo log` 文件，状态变为 `prepare`（预提交）
        - Server 层将 `binlog cache` 中的逻辑日志刷盘到 `binlog` 文件中，成为永久日志，支持主从复制和恢复
        - 当 `binlog` 刷盘成功后，Server 通知存储引擎将 `redo log` 状态从 `prepare` 切换到 `commit`
        - 此时，事务正式提交完成。MySQL 通过 **WAL（Write-Ahead Logging）+ 两阶段提交（2PC）** 机制，保证 `binlog` 与 `redo log` 的数据一致性



## 8-5- MySQL 提示“不存在此列”是执行到哪个节点报出的

在Parser：解析器分析 sql 语法的时候检查的列



## 8-6-如果一张表创建了多个索引，在哪个阶段或模块进行的索引选择

在优化器阶段Optimizer：查询优化器



# 9-日志

## 9-1- Mysql 会产生几种日志

| 日志                         | 说明                                          |
| ---------------------------- | --------------------------------------------- |
| 错误日志（error log）        | 记录MySQL在启动、关闭或者运行过程中的错误信息 |
| 慢查询日志（slow query log） | 记录在MySQL中响应时间超过阀值的语句           |
| 重写日志（redo log）         | 如下                                          |
| 回滚日志（undo log）         | 如下                                          |
| 二进制日志（bin log）        | 如下                                          |

| 类型         | 所属组件            | 作用                                                         | 持久化时机           | 物理/逻辑 | 是否参与崩溃恢复 |
| ------------ | ------------------- | ------------------------------------------------------------ | -------------------- | --------- | ---------------- |
| **redo log** | InnoDB              | 用于**崩溃恢复**，实现 WAL（先写日志）机制，确保事务提交后数据不丢 | 事务提交前写入磁盘   | 物理日志  | ✅ 是             |
| **undo log** | InnoDB              | 用于**事务回滚** 和 **MVCC 快照读**，存储修改前的旧值        | 随事务执行生成       | 逻辑日志  | ✅ 是             |
| **binlog**   | Server 层（全引擎） | 用于**主从复制**、**数据恢复**，记录所有对数据的修改操作（DML/DDL） | 事务提交时一次性写入 | 逻辑日志  | ❌ 否             |



## 9-2-聊一聊 redo log

- redo log（重做日志）是 InnoDB 存储引擎<font color="red">独有</font>的，是<font color="red">物理日志</font>，让 MySQL 拥有了<font color="red">崩溃恢复能力</font>
- 记录的是数据页的物理变化，用于服务宕机后的恢复，保证事务的<font color="red">持久性</font>



## 9-3- redo log 刷盘时机

InnoDB 将 `redo log` 刷到磁盘上有几种情况：

- <font color="red">事务提交</font>：当事务提交时，`log buffer` 里的 `redo log` 会被刷新到磁盘（可以通过`innodb_flush_log_at_trx_commit`参数控制）
- <font color="red">`redo log buffer`空间不足</font>时：`redo log buffer` 中缓存的记录已经占满了总容量的大约一半以上时，就需要把这些日志刷新到磁盘上
- <font color="red">后台刷新线程</font>：InnoDB 启动了一个后台线程，周期性（每隔 1 秒）地将脏页（已修改但尚未写入磁盘的数据页）刷新到磁盘，并将相关的重做日志一同刷新到磁盘
- <font color="red">正常关闭服务器</font>：MySQL 关闭的时候，`redo log` 都会刷入到磁盘里去



`innodb_flush_log_at_trx_commit` 的值有 3 种，也就是共有 3 种刷盘策略：

- **0**：设置为 0 的时候，表示每次事务提交时<font color="red">不进行刷盘操作</font>。这种方式性能最高，但是也最不安全，因为如果 MySQL 挂了或宕机了，可能会丢失最近 1 秒内的事务
- **1**：默认值为 1 ，表示<font color="red">每次事务提交时都将进行刷盘操作</font>。这种方式性能最低，但是也最安全，因为只要事务提交成功，`redo log` 记录就一定在磁盘里，不会有任何数据丢失
- **2**：设置为 2 的时候，表示每次事务提交时都只把 `log buffer` 里的 `redo log` 内容写入 `page cache`（文件系统缓存）。`page cache` 是专门用来缓存文件的，这里被缓存的文件就是 `redo log` 文件。这种方式的性能和安全性都介于前两者中间



另外，InnoDB 存储引擎有一个后台线程，每隔`1` 秒，就会把 `redo log buffer` 中的内容写到文件系统缓存（`page cache`），然后调用 `fsync` 刷盘

![image-20250519185712820](https://picgo-zjp.oss-cn-shenzhen.aliyuncs.com/image-20250519185712820.png)



## 9-4- redo log 是怎么保证持久性的

Write-ahead logging（WAL）：在事务提交之前，将事务所做的修改操作记录到redo log中，然后再将数据写入磁盘。这样即使在数据写入磁盘之前发生了宕机，系统可以通过redo log中的记录来恢复数据



## 9-5-讲一下 undo log

==定义 -> 工作流程==

- undo log记录的是<font color="red">逻辑日志</font>，记录的是 SQL 语句，用于事务回滚时恢复原始数据，保证事务的<font color="red">原子性和一致性</font>，undo log 还有一个作用，通过 ReadView + undo log 实现 <font color="red">MVCC</font>（多版本并发控制）
- 工作流程：在事务没提交之前，MySQL 会先记录更新前的数据到 undo log 日志文件里面，当事务回滚时，可以利用 undo log 来进行回滚



## 9-6-有了 undo log 为啥还需要 redo log

==Buffer Pool（更新流程、缺点） -> WAL -> redo log -> 总结==

- Buffer Pool：
    - 更新过程：将数据页从磁盘文件加载到 Buffer Pool，InnoDB 引擎就会先更新内存（同时标记为脏页），然后将本次对这个页的修改以 redo log 的形式记录下来，这个时候更新就算完成了
    - 存在问题：在 MySQL 中对数据的修改是在 <font color="red">Buffer Pool</font> 中的，Buffer Pool 是基于内存的，内存总是不可靠，万一断电重启，<font color="red">还没来得及落盘</font>的脏页数据就会丢失
- WAL（Write-Ahead Logging）：更新完成之后，InnoDB 引擎会在适当的时候，由<font color="red">后台线程</font>将缓存在Buffer Pool 的脏页刷新到磁盘里（MySQL 的写操作并不是立刻写到磁盘上，而是先写日志，然后在合适的时间再写到磁盘上）
- redo log：在事务提交时，只要先将 redo log 持久化到磁盘即可，可以不需要等到将缓存在 Buffer Pool 里的脏页数据持久化到磁盘
- 总结：事务提交之前发生了崩溃，重启后会通过 undo log 回滚事务，事务提交之后发生了崩溃，重启后会通过 redo log 恢复事务



## 9-7-讲一下 binlog

==Server层 -> 追加写，用于 -> 记录的内容是什么 -> 记录格式 -> 写入机制==

- binlog 是 MySQL 的 <font color="red">Server 层</font>实现的日志，所有存储引擎都可以使用
- binlog 是<font color="red">追加写</font>，写满一个文件，就创建一个新的文件继续写，不会覆盖以前的日志，保存的是全量的日志，<font color="red">用于备份恢复、主从复制</font>
- binlog 文件是记录了所有<font color="red">DDL（数据定义语言）语句和 DML（数据操纵语言）语句</font>的日志，不会记录查询类的操作
- binlog 有 3 种记录格式，分别是 STATEMENT（默认格式）、ROW、 MIXED
- 写入机制：事务执行过程中，先把日志写到`binlog cache`（Server 层的 cache），事务提交的时候，再把`binlog cache`写到 `binlog` 文件中



## 9-8- binlog 两阶段提交过程是怎么样的

为什么需要两阶段提交：事务提交后，redo log 和 binlog 都要持久化到磁盘，但是这两个是<font color="red">独立的逻辑</font>，可能出现半成功的状态，这样就造成两份日志之间的<font color="red">逻辑不一致</font>

MySQL使用了<font color="red">内部 XA 事务</font>，内部 XA 事务由 binlog 作为协调者，存储引擎是参与者

当客户端执行 commit 语句或者在自动提交的情况下，MySQL 内部开启一个 XA 事务，分两阶段来完成 XA 事务的提交，如下图：

![image-20250612203656985](https://picgo-zjp.oss-cn-shenzhen.aliyuncs.com/image-20250612203656985.png)

从图中可看出，事务的提交过程有两个阶段，就是将 redo log 的写入拆成了两个步骤：prepare 和 commit，中间再穿插写入binlog，具体如下：

- **prepare 阶段**：将 XID（内部 XA 事务的 ID） 写入到 redo log，同时将 redo log 对应的事务状态设置为 prepare，然后将 redo log 持久化到磁盘（innodb_flush_log_at_trx_commit = 1 的作用）
- **commit 阶段**：把 XID 写入到 binlog，然后将 binlog 持久化到磁盘（sync_binlog = 1 的作用），接着调用引擎的提交事务接口，将 redo log 状态设置为 commit，此时该状态并不需要持久化到磁盘，只需要 write 到文件系统的 page cache 中就够了，因为只要 binlog 写磁盘成功，就算 redo log 的状态还是 prepare 也没有关系，一样会被认为事务已经执行成功



## 9-9-能不能只用 binlog 不用 redo log

不行，binlog是 <font color="red">server 层</font>的日志，没办法记录哪些<font color="red">脏页</font>还没有刷盘，redolog 是存储引擎层的日志，可以记录哪些脏页还没有刷盘，这样崩溃恢复的时候，就能恢复那些还没有被刷盘的脏页数据



## 9-10- Mysql 日志是否实时写入磁盘

| 日志类型     | 是否实时写盘             | 刷盘控制参数                       | 完善说明                                                     |
| ------------ | ------------------------ | ---------------------------------- | ------------------------------------------------------------ |
| **redo log** | 否（默认延迟）           | `innodb_flush_log_at_trx_commit`   | InnoDB 的重做日志，用于**崩溃恢复**，记录已提交事务对数据页的修改；写入 redo log buffer 后根据策略刷盘，**事务提交时是否立即落盘取决于参数**，默认值 `1` 表示每次提交都刷盘（强一致性），可提升数据安全性 |
| **undo log** | 否                       | 无需专门刷盘参数（与数据页一起刷） | InnoDB 的回滚日志，用于**事务回滚和 MVCC 版本控制**，不单独立即刷盘，而是随着数据页由后台线程定期写入磁盘；**刷盘机制依赖 InnoDB 的脏页刷新策略** |
| **binlog**   | 否（默认不实时，需配置） | `sync_binlog`                      | Server 层的二进制日志，用于**主从复制、数据恢复、审计**；事务提交时一次性写入，是否立即刷盘取决于 `sync_binlog` 设置，`1` 表示每次提交强制刷盘，**保障主从一致性**，但对性能有一定影响 |



## 9-11- Mysql 集群同步时为什么使用 binlog

| 分类                                 | 内容                                                         |
| ------------------------------------ | ------------------------------------------------------------ |
| 📘 **定义**                           | binlog（二进制日志）是 **MySQL Server 层生成的逻辑日志**，记录的是对数据库执行的增删改等操作，不包含查询语句，不依赖具体存储引擎。所有存储引擎都支持。 |
| 🧩 **主从复制核心机制**               | MySQL 主从复制通过 binlog 实现。主库将 binlog 写入磁盘，从库通过 I/O 线程读取 binlog 并重放，确保主从数据一致。 |
| ✅ **优势一：逻辑清晰、可重放**       | binlog 记录的是 SQL 语句或行级变更（row-based），便于按顺序回放操作，确保一致性。 |
| ✅ **优势二：增量同步支持**           | binlog 持续记录事务操作，支持从断点 offset 处恢复同步，便于断点续传，减少全量复制开销。 |
| ✅ **优势三：与中间件集成**           | binlog 可被 Canal、Maxwell、Debezium 等中间件读取，实现数据同步到 Kafka、HDFS、Elasticsearch 等系统。 |
| ✅ **优势四：跨版本与跨实例兼容性好** | 与 redo log 不同，binlog 是逻辑日志，不依赖底层存储结构，适合不同版本、不同实例间复制。 |
| ⚠️ **为什么不用 redo / undo**         | redo/undo 是 InnoDB 的物理日志，只在本地用于恢复和事务管理，不具备跨实例同步能力。 |
| ❌ **复制表文件的问题**               | 复制 .ibd 或 .frm 等数据文件不能保障事务一致性，也不支持按时间点恢复；复制中断后很难确定复制位置，数据一致性不可控。 |



# 10-开发经验

## 10-1-日期，时间如何存取

在 MySQL 中，存储日期时间通常使用内建的时间类型，而非字符串。常见的时间类型有：

| 类型        | 存储字节 | 支持范围                                           | 精度（MySQL 5.6+ 支持小数秒） | 是否受时区影响 |
| ----------- | -------- | -------------------------------------------------- | ----------------------------- | -------------- |
| `DATE`      | 3 字节   | 1000-01-01 到 9999-12-31                           | 无                            | 否             |
| `TIME`      | 3 字节   | -838:59:59 到 838:59:59                            | 支持                          | 否             |
| `DATETIME`  | 8 字节   | 1000-01-01 00:00:00 到 9999-12-31 23:59:59         | 支持                          | 否             |
| `TIMESTAMP` | 4 字节   | 1970-01-01 00:00:01 UTC 到 2038-01-19 03:14:07 UTC | 支持                          | ✅ 是           |

`TIMESTAMP` vs `DATETIME` 的区别：

| 比较点         | `TIMESTAMP`                        | `DATETIME`                         |
| -------------- | ---------------------------------- | ---------------------------------- |
| 存储方式       | 存储为 UTC 时间戳（整数）          | 以字符串格式存储完整时间           |
| 显示方式       | 显示为当前时区下的本地时间         | 显示为录入时的时间，无时区转换     |
| 是否受时区影响 | ✅ 是（插入/查询会自动转换）        | ❌ 否（固定值，时区变化无影响）     |
| 占用空间       | ✅ 较小（4 字节）                   | ⛔ 较大（8 字节）                   |
| 推荐用途       | 存储**时间戳、记录变更时间**等     | 存储**绝对时间，如生日、事件时间** |
| 2038 问题      | 有（最大值受限于 Unix 时间戳范围） | 无（范围远大）                     |

为什么不建议使用字符串存储日期时间

- **空间浪费**：字符串如 `"2024-05-10 13:45:00"` 占用至少 19 字节，而 `DATETIME` 只需 8 字节
- **效率低**：字符串不支持高效的范围查询、排序、索引，查询性能差
- **语义不清晰**：字符串容易录入错误或格式不一致，如 `"2024/5/10"`、`"10-05-2024"`
- **无法进行时间计算**：字符串不能直接进行加减、间隔计算等，需要先转换格式



## 10-2-需要使用时间戳 timestamp 和 int 该如何选择

| 比较项             | `TIMESTAMP`                                           | `INT`（存储 Unix 时间戳，如 `INT(10)`）     |
| ------------------ | ----------------------------------------------------- | ------------------------------------------- |
| **存储格式**       | 内部以 Unix 时间戳存储，显示为日期时间格式            | 存储为整数（单位：秒）                      |
| **可读性**         | ✅ 自动转为 `YYYY-MM-DD hh:mm:ss`，人类可读            | ❌ 需手动转换（如 `FROM_UNIXTIME()`）        |
| **自动处理时区**   | ✅ 会自动根据时区进行转换                              | ❌ 不处理时区                                |
| **自动初始化**     | ✅ 可使用 `DEFAULT CURRENT_TIMESTAMP` 自动写入当前时间 | ❌ 不支持自动写入当前时间                    |
| **存储空间**       | ✅ 4 字节（MySQL 5.6+ 可带小数秒）                     | ✅ 4 字节（也可用 `BIGINT` 存毫秒）          |
| **最大表示范围**   | ⛔ 到 2038-01-19（32 位 Unix 时间戳）                  | ✅ 最大可表示 `2147483647`（约2038年）或更大 |
| **时间计算**       | ✅ 可直接进行时间间隔、函数处理                        | ❌ 需转为时间格式才能进行计算                |
| **是否受时区影响** | ✅ 受时区影响                                          | ❌ 不受时区影响                              |



## 10-4-财务计算有没有出现过错乱

| 类别            | 问题描述                               | 常见原因 / 场景                                              | 解决方案 / 实践建议                                          |
| --------------- | -------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **并发问题**    | 多线程或多用户操作导致数据不一致       | - 多线程共享变量无同步- 用户操作提交前 UI 超时- 并发提交订单等 | - 使用线程安全的数据结构或加锁机制- 控制提交超时策略- 数据库加 **悲观锁**：`SELECT ... FOR UPDATE` |
| **精度问题**    | 浮点运算误差、金额计算不准确           | - 使用 `float` / `double` 进行金额计算- 除法精度丢失         | - 使用 `BigDecimal` 或数据库中的 `DECIMAL` 类型- 用乘法代替除法（避免除不尽） |
| **事务问题**    | 部分操作提交失败导致状态不一致         | - 未开启事务或事务范围错误- 异常未回滚- 跨多库事务失败       | - 使用数据库事务确保 **ACID** 特性- 明确控制提交与回滚时机   |
| **数据删除**    | 数据被误删或不可恢复                   | - 直接物理删除导致无法审计- 操作误删记录                     | - 使用**逻辑删除**（设置删除标识位）- 审计字段记录操作人和时间 |
| **审计追溯**    | 出现错误后无法还原或定位问题           | - 日志不全- 操作无记录- 账务数据无快照或对账信息             | - 记录详细日志（操作日志、变更记录）- 保留历史数据快照或账务流水备份 |
| **UI 提交问题** | 用户在界面操作未及时提交或提交状态混乱 | - 会话过期- 表单重复提交- 未判断前端状态                     | - 设置前端防抖与唯一 token 限制重复提交- 后端校验请求有效性  |



## 10-5-decimal与float,double的区别是什么

| 项目                  | `DECIMAL`（定点数）                                  | `FLOAT`（单精度浮点）                            | `DOUBLE`（双精度浮点）                               |
| --------------------- | ---------------------------------------------------- | ------------------------------------------------ | ---------------------------------------------------- |
| **存储方式**          | 以字符串形式存储，精确表示十进制                     | 以二进制浮点存储（IEEE 754）                     | 以二进制浮点存储（IEEE 754）                         |
| **精度**              | ✅ 精度高，完全无误差，适合财务等场景                 | ❌ 存在精度误差，易出现四舍五入等问题             | ❌ 精度比 FLOAT 高，但仍有误差                        |
| **适用场景**          | 金额、财务、精确计算，如银行、电商交易               | 科学计算、图像处理、临时计算等对精度要求不高场景 | 对精度要求高于 float，但仍可容忍小误差的科学计算场景 |
| **计算性能**          | ❌ 较慢（精度换来的代价）                             | ✅ 计算速度快                                     | ✅ 较快                                               |
| **存储空间（MySQL）** | 可指定精度，如 `DECIMAL(10,2)`，每 9 位数字约 4 字节 | 4 字节                                           | 8 字节                                               |
| **是否建议用于金额**  | ✅ 推荐（避免误差）                                   | ❌ 不推荐                                         | ❌ 不推荐                                             |



## 10-6-预编译 sql 是什么

SQL 预编译就是先将 SQL 结构发送给数据库编译好，后续只需传递参数即可执行

**优点**

| 优点                 | 说明                                              |
| -------------------- | ------------------------------------------------- |
| **防止 SQL 注入**    | 参数不拼接在 SQL 中，而是绑定传入，避免恶意注入。 |
| **提升性能**         | SQL 结构只编译一次，后续复用执行计划，效率更高。  |
| **节省网络传输成本** | 参数单独传送，减少字符串拼接体积和解析开销。      |



## 10-7-子查询与 join 哪个效率高

**通常情况下，`JOIN` 比子查询效率高**，因为 JOIN 允许数据库优化器采用更优的执行计划，而子查询（尤其是嵌套子查询）往往执行顺序固定、难以优化

| 比较项       | 子查询                         | JOIN                               |
| ------------ | ------------------------------ | ---------------------------------- |
| **执行机制** | 通常先执行内层子查询，再外层   | 优化器可选择执行顺序、构建连接方式 |
| **优化空间** | 优化器难以改写嵌套子查询       | 优化器可自由调度 JOIN 的执行顺序   |
| **中间结果** | 子查询可能生成临时表或中间结果 | JOIN 可通过嵌套循环/哈希/排序优化  |
| **可读性**   | 层级结构清晰但不易优化         | 多表连接语义清晰，优化潜力更大     |
| **场景适配** | 适合返回单值、过滤子集         | 适合多表联合查询、复杂条件匹配     |

**子查询效率低的常见原因：**

1. **嵌套执行，缺乏优化**
    - 特别是 **相关子查询（correlated subquery）**，每执行一行都要跑一次子查询，性能非常差
2. **不能使用索引优化**
    - 有些写法（如 `IN (SELECT ...)`）在旧版本 MySQL 中无法有效使用索引
3. **生成临时表/物化结果**
    - 子查询结果需先生成中间表，再参与外层查询，增加 IO 成本



## 10-8-如何优化过多 join 查询关联

- 适当使用冗余字段减少多表关联查询
- 驱动表和被驱动表（小表join大表）
- 业务允许的话 尽量使用inner join 让系统帮忙自动选择驱动表
- 关联字段一定创建索引
- 调整JOIN BUFFER大小



# 11-SQL题
