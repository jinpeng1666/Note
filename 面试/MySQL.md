# 1-索引

## 1-1-什么是索引

==索引（index）是帮助MySQL高效获取数据的数据结构(有序)==，主要用来提高数据<font color='red'>检索效率</font>，降低数据库的I/O成本同时，索引列可以对数据进行排序，降低<font color="red">数据排序</font>的成本，也能减少CPU的消耗



## 1-2-索引有哪些

1. <font color="red">数据结构维度划分</font>：
    - BTree 索引：MySQL 里默认和最常用的索引类型
    - 哈希索引：类似键值对的形式，一次即可定位
    - 全文索引：对文本的内容进行分词，进行搜索
2. <font color="red">底层存储方式角度划分</font>：
    - 聚簇索引（聚集索引）：索引结构和数据一起存放的索引
    - 非聚簇索引（非聚集索引）：索引结构和数据分开存放的索引
3. <font color="red">应用维度划分</font>：
    - 主键索引：加速查询 + 列值唯一（不可以有 NULL）+ 表中只有一个
    - 唯一索引：加速查询 + 列值唯一（可以有 NULL）
    - 普通索引：仅加速查询
    - 联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并
    - 覆盖索引：一个索引包含（或者说覆盖）所有需要查询的字段的值
    - 全文索引：对文本的内容进行分词，进行搜索。目前只有 `CHAR`、`VARCHAR`、`TEXT` 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替
    - 前缀索引：对文本的前几个字符创建索引，相比普通索引建立的数据更小，因为只取前几个字符



### 1-2-1-什么是聚集索引和非聚集索引

在InnoDB存储引擎中，根据<font color="red">索引的存储形式</font>，又可以分为以下两种：

| 分类                     | <font color="red">含义</font>                              | <font color="red">数量</font> |
| ------------------------ | ---------------------------------------------------------- | ----------------------------- |
| 聚集索引(ClusteredIndex) | 将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据 | 必须有,而且只有一个           |
| 二级索引(SecondaryIndex) | 将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键 | 可以存在多个                  |

聚集索引<font color="red">选取规则</font>:

- 如果存在主键，主键索引就是聚集索引
- 如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引
- 如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引



聚集索引和二级索引的具体结构如下：

![image-20250417122905676](https://picgo-zjp.oss-cn-shenzhen.aliyuncs.com/image-20250417122905676.png)

- 聚集索引的叶子节点下挂的是这一行的数据
- 二级索引的叶子节点下挂的是该字段值对应的主键值



**聚簇索引**

![image-20250508161447214](https://picgo-zjp.oss-cn-shenzhen.aliyuncs.com/image-20250508161447214.png)

**特点：**

- 索引和数据保存在同一个B+树中

- 页内的记录是按照主键的大小顺序排成一个单向链表 
- 页和页之间也是根据页中记录的主键的大小顺序排成一个双向链表 
- 非叶子节点存储的是记录的主键+页号
- 叶子节点存储的是完整的用户记录

**优点：**

- 数据访问更快 ，因为索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快。
- 聚簇索引对于主键的排序查找和范围查找速度非常快
- 按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库可以从更少的数据块中提取数据，节省了大量的IO操作 

**缺点：**

- 插入速度严重依赖于插入顺序 ，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键
- 更新主键的代价很高 ，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义主键为不可更新

**限制：**

- 只有InnoDB引擎支持聚簇索引，MyISAM不支持聚簇索引
- 由于数据的物理存储排序方式只能有一种，所以每个MySQL的表只能有一个聚簇索引
- 如果没有为表定义主键，InnoDB会选择非空的唯一索引列代替。如果没有这样的列，InnoDB会隐式的定义一个主键作为聚簇索引
- 为了充分利用聚簇索引的聚簇特性，InnoDB中表的主键应选择有序的id，不建议使用无序的id，比如UUID、MD5、HASH、字符串作为主键，无法保证数据的顺序增长



### 1-2-2-什么是唯一索引

唯一索引（Unique Index）是一种强制索引列中的值唯一的索引类型，用来防止数据库表中的数据出现重复值



### 1-2-3-什么叫覆盖索引

覆盖索引是指在SELECT查询中，返回的列全部能在索引中找到，避免了回表查询，提高了性能。使用覆盖索引可以减少对主键索引的查询次数，提高查询效率



### 1-2-4-什么是联合索引

一个索引同时包含多个列（字段），在一个索引结构中对多个字段联合排序，从而加速多条件查询

**特点**

- 按“最左前缀”原则生效
- 节省索引空间，提高效率
- 可用于覆盖索引



## 1-3-索引的优缺点是什么

### 优点

- 使用索引可以大大加快数据的<font color="red">检索速度</font>（大大减少检索的数据量），减少 IO 次数
- 索引是<font color="red">有序</font>的数据结构，排序成本低，范围查询效率高
- 通过创建唯一性索引，可以保证数据库表中每一行数据的<font color="red">唯一性</font>

### 缺点

- <font color="red">创建和维护</font>索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态地修改，这会降低 SQL 执行效率
- 索引需要使用物理文件存储，也会耗费一定<font color="red">存储空间</font>



## 1-4-什么是索引下推

索引下推（Index Condition Pushdown，ICP）是MySQL 5.6引入的一种优化查询效率的技术，==它允许存储引擎在索引遍历过程中，执行部分 `WHERE` 字句的判断条件，直接过滤掉不满足条件的记录，从而减少回表次数，提高查询效率==



## 1-5-什么是回表查询

回表查询是指通过二级索引找到对应的主键值，然后再通过主键值查询聚簇索引中对应的整行数据的过程



## 1-6-InnoDB索引与MyISAM索引实现的区别是什么

- <font color="red">索引结构</font>：
    - InnoDB：聚簇索引
        - 每张表必须有主键，若未指定，系统自动选择或创建一个隐藏主键
        - 表数据按主键顺序存储在聚簇索引的叶子节点中，数据本身就是主键索引的一部分
        - 二级索引（辅助索引）的叶子节点保存的是对应记录的主键值，访问真实数据时需要回表一次（通过主键再查聚簇索引）
    
    - MyISAM：非聚簇索引
        - 所有索引结构都是非聚簇的
        - 访问数据时，直接通过地址定位数据，无需再走主键或其他索引
- <font color="red">存储方式</font>：
    - InnoDB：
        - 索引与数据在同一个文件中（`.ibd` 文件）
        - 聚簇结构决定数据物理上按主键排序存储
    - MyISAM：
        - 数据（`.MYD`）与索引（`.MYI`）分离存储
        - 索引仅作为数据位置的指针存在，不包含实际数据内容

- <font color="red">主键机制</font>：
    - InnoDB：必须有主键
        - 若未设置主键，系统会自动选择一个候选键
        - 若没有任何候选键，InnoDB 会自动创建一个6字节的隐藏主键
    - MyISAM：无主键强制要求
        - 可以没有主键
        - 无自动生成主键的行为
- <font color="red">回表方式和效率差异</font>：
    - InnoDB 回表效率略低
        - 二级索引访问数据需要先获取主键，再回聚簇索引查询
        - 优点是支持 MVCC、多事务安全、并发控制优异
    - MyISAM 回表效率高
        - 索引直接存储物理地址，定位数据时性能更优
        - 但缺点是 不支持事务、不支持 MVCC、并发能力弱

![image-20250508122629195](https://picgo-zjp.oss-cn-shenzhen.aliyuncs.com/image-20250508122629195.png)



## 1-7-聊聊索引的底层数据结构

<font color="red">不同存储引擎使用不同索引</font>：

- MySQL的默认存储引擎InnoDB使用的是B+树作为索引的存储结构

- MyISAM引擎使用B+树作为索引，但和InnoDB有所不同

- Memory 引擎使用哈希索引



<font color="red">B+树的定义</font>：

B+树（**B+ Tree**）是一种**多路平衡查找树**，具有以下特点：

- 非叶子节点只存储 key，不存储数据（data）
- 所有叶子节点之间通过链表顺序连接，便于范围查询
- 树是平衡的，从根节点到任意叶子节点路径长度相同



在默认存储引擎中，相比于其他结构（如哈希表、B 树、红黑树等），<font color="red">选择B+树的原因</font>包括：

1. **树的高度更低，查询更快**：B+树的节点对应磁盘中的一个“页”，非叶子节点只存 key 和指针，在相同数据量的情况下，B+树的层级比B树低，查找路径更短，性能更优
2. **更高的磁盘读写效率（IO友好）**：树的层数越低，IO次数就越少，性能就越高
3. **范围查询更高效**：所有数据都集中在叶子节点，并且叶子节点通过双向链表连接，因此可以非常高效地进行范围查询和全表扫描



## 1-8-B树和B+树的区别是什么

- <font color="red">数据存储方式</font>：B 树的所有节点既存放键(key)也存放数据(data)，而 B+ 树只有叶子节点存放 key 和 data，其他内节点只存放 key，相同数据量的情况下，B+树的高度更低，更扁平化，IO次数就越少，所以磁盘读写代价低

- <font color="red">叶子节点</font>：B 树的叶子节点都是独立的；B+ 树的叶子节点之间形成了双向链表，范围查询和排序的效率更高

综上，B+ 树与 B 树相比，具备==更少的 IO 次数、更稳定的查询效率和更适于范围查询==这些优势





## 1-9-CRUD时聚簇索引与非聚簇索引的区别是什么

| 操作类型           | 聚簇索引                                                     | 非聚簇索引                                                 |
| ------------------ | ------------------------------------------------------------ | ---------------------------------------------------------- |
| **Create（插入）** | 插入时需确保主键有序，可能引发页分裂、记录移动；**插入到中间位置性能略低** | 插入仅修改索引结构本身，不涉及数据页重排，**插入开销小**   |
| **Read（查询）**   | 查询效率高，**无需回表**，适合范围查找、排序、分页等操作     | 查询字段不完整时需回表一次，**存在二次查找开销**           |
| **Update（更新）** | 更新主键会引发数据位置变动，代价大（不推荐更新主键）         | 更新非聚簇索引字段可能需修改索引结构；更新数据页仍需回表   |
| **Delete（删除）** | 删除记录就是删除叶子节点数据，较直接                         | 删除时需先通过主键定位原始数据页，**比聚簇索引多一次查找** |



## 1-10-索引创建原则有哪些（如何正确使用索引）

表->字段->索引

1. **大表：**针对于数据量较大（10万+），且查询比较频繁的表建立索引
2. **字段：**针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引
3. **字符串字段：**如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引
4. **高区分度字段：**尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高
5. **联合索引：**尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率
6. **索引数量：**要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率
7. **避免 NULL：**如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询



## 1-11-什么情况下索引会失效

最左->数据匹配（索引列运算、字符引号、模糊查询）->OR连接和范围查询->数据分布影响

| 情况                 | 原因和说明                                                   |
| -------------------- | ------------------------------------------------------------ |
| **最左前缀匹配原则** | 联合索引必须从最左列开始依次匹配，不能跳过中间列。跳过某列后，该列及其后续列的索引会失效。✅如索引 (a, b, c)：`WHERE a = ? AND b = ?` 可用；❌ `WHERE b = ?`、`WHERE a = ? AND c = ?` 会导致索引部分失效。 |
| **索引列运算**       | 在索引列上进行函数或表达式运算（如 `YEAR(date)`、`age + 1`）会使 MySQL 无法使用索引中的原始值，导致全表扫描。 |
| **字符串不加引号**   | 字符串字段查询时若不加引号（如 `WHERE name = 123`），会发生类型转换，触发索引失效并进行全表扫描。 |
| **模糊查询**         | `LIKE 'abc%'` 可使用索引；`LIKE '%abc'` 或 `LIKE '%abc%'` 会导致无法利用索引，必须扫描全表。 |
| **OR 连接条件**      | **仅当 OR 两侧所有字段都建立了索引时，MySQL 才能使用索引**。否则会放弃使用索引，执行全表扫描。✅如：`WHERE name = 'Tom' OR age = 18` 且 name、age 都有索引 → 索引可用；❌ name 有索引但 age 无索引 → 索引失效，走全表。 |
| **范围查询**         | 在联合索引中，一旦某列使用范围查询（如 `<`, `>`, `BETWEEN`），**其后面的字段索引将失效**。✅例如：索引 (a, b, c)，查询 `WHERE a = 1 AND b > 5` → c 无法使用索引。⚠ 注意：`>=` 和 `<=` 本质仍是范围查询，后续字段依然失效。 |
| **数据分布影响**     | 字段的“区分度”（不同值的比例）低，会降低索引效率。如性别字段只有“男/女”，使用索引意义不大，优化器可能选择全表扫描更快。建议优先对高区分度字段建索引。 |



## 1-12-一个b+树中大概能存放多少条索引记录

- **B+树的结构特点：**
    - B+树是一种多路平衡搜索树，所有实际的数据记录都存储在叶子节点，非叶子节点只存储键值和指针
    - 相比B树，B+树的非叶子节点更“轻”，因为它们不包含实际数据，因此单个非叶子节点可以容纳更多键值和指针，这意味着树的扇出更大，整体高度更小
- **关键估算维度：**
    - 每个节点的页大小
    - 每条索引项（键值 + 指针）的大小
    - 每条数据记录的大小（影响叶子节点的记录数）
    - 扇出（fan-out）：非叶子节点中可容纳的指针数量，决定了树的分支能力

 B+树的扇出非常高，**实际生产环境中一般只需要 2~3 层就可以支持上千万甚至上亿条记录**



## 1-13-使用B+树存储的索引crud执行效率如何

使用 B+ 树作为索引结构，在执行 CRUD 操作时整体效率是比较高的

- 查询方面，它是有序结构，所有数据都在叶子节点上，通过从根节点查找到叶子节点，再加上叶子节点之间有链表连接，所以无论是<font color="red">精确查找还是范围查询</font>，效率都非常高

- 插入和删除操作只影响局部的节点，可能涉及<font color="red">节点分裂或合并</font>，但由于树高不大，这些操作通常不会带来太大开销

- 更新的话，如果更新的是<font color="red">非索引字段</font>，几乎不影响效率；但如果更新的是索引字段，相当于一次删除再插入，代价相对高一些

所以总体来看，B+树最适合读多写少、特别是有排序或范围查询需求的场景，比如数据库主键索引或者联合索引



## 1-14-什么是自适应哈希索引

自适应哈希索引是Innodb引擎的一个特殊功能，当它==注意到某些索引值被使用的非常频繁时，会在内存中基于B-Tree索引之上再创建一个哈希索引，这就让B-Tree索引也具有哈希索引的一些优点==，比如快速哈希查找。这是一个完全自动的内部行为，用户无法控制或配置



## 1-15-为什么官方建议使用自增长主键作为索引

**✅ 自增主键的优势：**

- <font color="red">顺序插入</font>：新数据始终追加在 B+ 树最右端，避免页分裂
- <font color="red">节省空间</font>：整型主键占用少，B+ 树扇出高、树更矮

**⚠️ 字符串主键的劣势：**

- <font color="red">插入无序</font>：容易在中间插入，导致页分裂、结构碎片
- <font color="red">占用空间大</font>：B+ 树扇出降低，树高增加



## 1-16-使用索引一定能提升效率吗

不一定

- <font color="red">少量数据</font>全表扫描也很快，可以直接获取到全量数据
- <font color="red">唯一索引</font>会影响插入速度，但建议使用
- 索引过多会影响<font color="red">更新、插入和删除数据速度</font>



## 1-17-非聚簇索引为什么不存数据地址值而存储主键？

- <font color="red">避免物理地址失效（页移动）</font>
    - 如果存物理地址，一旦发生页分裂、页合并或记录移动，地址会失效；那就要更新所有指向旧地址的索引项，维护代价高
    - 主键是逻辑标识，稳定不会变，维护成本更低
- <font color="red">便于构建覆盖索引</font>
    - 非聚簇索引可以存储“主键 + 查询字段”，成为覆盖索引；查询命中覆盖索引时，无需回表，效率更高
- **支持回表查询的一致性**
    - InnoDB 的主键索引就是数据本身（聚簇索引）
    - 非聚簇索引存主键值，可以在“回表”时准确查找整行
    - 保证逻辑结构统一、查找路径一致、维护更清晰



## 1-18-什么时候适合创建索引，什么时候不适合创建索引

| 类型                              | 是否推荐建索引 | 理由 / 注意事项            |
| --------------------------------- | -------------- | -------------------------- |
| **WHERE 子句字段**                | ✅ 推荐         | 提升查询性能，避免全表扫描 |
| **JOIN 连接字段**                 | ✅ 推荐         | 加快多表连接效率           |
| **ORDER BY 字段**                 | ✅ 推荐         | 使用索引避免排序和临时表   |
| **GROUP BY 字段**                 | ✅ 推荐         | 排序加速，避免额外排序开销 |
| **COUNT、MAX 等聚合字段**         | ✅ 推荐         | 利用索引加速聚合函数       |
| **主键字段**                      | ✅ 强制         | 自动创建聚簇索引，物理排序 |
| **唯一字段（如身份证、邮箱）**    | ✅ 推荐         | 保证数据唯一性，避免脏数据 |
| **频繁更新的字段**                | ❌ 不推荐       | 索引维护成本高，影响写性能 |
| **重复值过多的字段（如性别）**    | ❌ 不推荐       | 选择性差，索引命中率低     |
| **参与函数计算的字段**            | ❌ 不推荐       | 函数会导致索引失效         |
| **数据量极小的表**                | ❌ 不推荐       | 查询速度本就很快，无需索引 |
| **查询中永远不会用到的字段**      | ❌ 不推荐       | 增加维护开销，浪费空间     |
| **范围查询字段（BETWEEN, >, <）** | ✅ 推荐         | 利用索引有序特性，高效查找 |
| **排序 + LIMIT 场景**             | ✅ 推荐         | 联合索引可加速分页查询     |





## 1-19-一个表有多个索引的时候，能否手动选择使用哪个索引

MySQL会自动选择认为最优的索引，但你也可以通过手动方式影响或指定使用哪个索引



## 1-20-多个索引优先级是如何匹配的

1. 主键（唯一索引）匹配
2. 全值匹配（单值匹配）
3. 最左前缀匹配
4. 范围匹配
5. 索引扫描
6. 全表扫描



MySQL查询<font color="red">优化器</font>会根据 **代价估算原则（Cost-Based Optimization）**，选择预计执行代价最低的那个索引

- 索引选择性（Selectivity）优先
    - 选择性 = 唯一值数量 / 总记录数
    - 越高代表过滤能力越强，越优先使用
    - 唯一索引（如主键）选择性最高，优先级最高
- 最左前缀匹配规则
    - 多列联合索引中，必须从最左列开始依次匹配
- 覆盖索引优先（无需回表）
- 排序/分组/范围兼容性
    - 优先选择能兼容 `ORDER BY`、`GROUP BY`、`BETWEEN` 的索引
    - 可利用索引中的有序特性提升性能
- 执行成本最低
    - 优化器基于表统计信息计算预估成本（行数、页数、IO次数）
    - 选择最便宜的执行计划



## 1-21-ORDER BY 是否使用索引排序

| 必要条件                         | 说明                                                         |
| -------------------------------- | ------------------------------------------------------------ |
| **排序字段必须在索引中**         | 可以是单列索引或联合索引的前缀部分                           |
| **WHERE 子句不能破坏索引顺序性** | 联合索引中出现范围查询（如 `>`, `<`, `BETWEEN`）字段之后的索引会失效 |
| **排序方向必须一致**             | 联合索引中多个字段排序，方向必须都为 ASC 或都为 DESC         |



## 1-22-group by 分组和order by在索引使用上有什么区别

group by 使用索引的原则几乎跟order by一致 ，唯一区别：

- group by 先排序再分组，遵照索引建的最佳左前缀法则
- group by没有过滤条件，也可以用上索引。Order By 必须有过滤条件才能使用上索引



# 2-SQL优化

## 2-1-如何定位慢查询

使用<font color="red">运维监控系统</font>（Skywalking等）；如果没有这种监控系统，MySQL本身也提供了<font color="red">慢查询日志</font>功能。可以在MySQL的系统配置文件中开启慢查询日志（默认不开启）（在MySQL的配置文件中配置），并设置SQL执行时间超过多少就记录到日志文件，比如我们之前项目设置的是2秒，超过这个时间的SQL就会记录在日志文件中，我们就可以在那里找到执行慢的SQL



## 2-2-SQL语句执行很慢，如何分析

如果一条SQL执行很慢，我们通常会使用MySQL的`EXPLAIN`命令来分析这条SQL的执行情况。通过`key`和`key_len`可以检查是否命中了索引，如果已经添加了索引，也可以判断索引是否有效。通过`type`字段可以查看SQL是否有优化空间，比如是否存在全索引扫描或全表扫描。通过`extra`建议可以判断是否出现回表情况，如果出现，可以尝试添加索引或修改返回字段来优化

**语法**

```mysql
-- 直接在select语句之前加上关键字 explain / desc
EXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件;
```

![image-20250507100409632](https://picgo-zjp.oss-cn-shenzhen.aliyuncs.com/image-20250507100409632.png)

![image-20250507100732063](https://picgo-zjp.oss-cn-shenzhen.aliyuncs.com/image-20250507100732063.png)



## 2-3-MySQL超大分页怎么处理

超大分页通常发生在数据量大的情况下，使用`LIMIT`分页查询且需要排序时效率较低。可以通过==覆盖索引和子查询==来解决。首先查询数据的ID字段进行分页，然后根据ID列表用子查询来过滤只查询这些ID的数据，因为查询ID时使用的是覆盖索引，所以效率可以提升



## 2-4-SQL的优化经验有哪些

- **表的设计优化**
- **索引优化**
- **SQL语句优化**
- **读写分离**
- **分库分表**



### 2-4-1-表的设计优化

- <font color="red">字段类型</font>选择合理：根据实际数据选择合适的数值类型（如 `tinyint`, `int`, `bigint`），避免为字段分配不必要的大长度
- <font color="red">字符串类型</font>匹配：
    - `CHAR`：适用于定长数据（如身份证号、手机号等），读取效率高
    - `VARCHAR`：适用于变长数据（如用户名、地址等），节省存储空间
- 拆分<font color="red">冗余字段</font>：遵循数据库设计范式（如第三范式），避免数据冗余和更新异常
- 添加必要<font color="red">约束</font>：如 `NOT NULL`、`DEFAULT`、`UNIQUE`、`CHECK` 等，有助于优化器做出更好判断



### 2-4-2-索引优化

遵循<font color="red">索引创建原则</font>



### 2-4-3-SQL语句优化

- <font color="red">明确字段名称</font>：避免 `SELECT *`，只查询必要字段，减少 I/O 和网络传输压力
- <font color="red">避免索引失效</font>的写法
- <font color="red">合理使用 JOIN</font>：
    - `INNER JOIN` 优于 `LEFT/RIGHT JOIN`
    - 让小表驱动大表，可提高嵌套循环连接效率
    - 使用 `ON` 条件替代 `WHERE` 后过滤
    
- **`UNION ALL` 优先于 `UNION`**：避免重复数据去重，提高性能
- <font color="red">减少嵌套子查询</font>：能使用 JOIN 的场景不建议用子查询，子查询执行效率通常较低
- **LIMIT + OFFSET** 优化：超大分页应使用 ID 过滤或子查询方式提升性能

> [!NOTE]
>
> 小表驱动大表是什么意思？
>
> - 数据库在做嵌套循环（Nested Loop Join）时，会先扫描驱动表，然后对每条记录去被驱动表中匹配
>
> - 小表驱动大表时，匹配次数更少，效率更高



### 2-4-4-读写分离

通过主从复制实现读写分离：

- 主库负责写操作，从库负责读操作
- 降低主库压力，提高整体系统性能



###  2-4-5-分库分表

**分表**：单表数据量过大时，按时间、范围或哈希方式拆分

**分库**：按业务模块或分区逻辑拆库，提升并发处理能力



# 3-事务

## 3-1-事务的特性是什么

> [!NOTE]
>
> 事务是什么？
>
> 事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败

- 原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败
- 一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态
- 隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行
- 持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的



## 3-2-并发事务带来哪些问题

并发事务可能导致脏读、不可重复读和幻读。

1. 脏读是指一个事务读到了另一个事务未提交的“脏数据”
2. 不可重复读是指在一个事务内多次读取同一数据，由于其他事务的修改导致数据不一致
3. 幻读是指一个事务读取到了其他事务插入的“幻行”
4. 修改丢失是指一个事务读取一个数据时，另外一个数据也访问了该数据，那么在第一个事务修改了这个数据之后，第二个事务也修改了这个数据，这样第一个事务内的修改结果就被丢失



## 3-3-MySQL的隔离级别有哪些

1. 未提交读（READ UNCOMMITTED）：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读
2. 读已提交（READ COMMITTED）：允许读取并发事务已经提交的数据，可以阻止脏读，但是不可重复读或幻读仍有可能发生
3. 可重复读（REPEATABLE READ）：默认的隔离级别，对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。但是，InnoDB 实现的 REPEATABLE-READ 隔离级别其实是可以解决幻读问题发生的
4. 串行化（SERIALIZABLE）：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读



## 3-4-事务中的隔离性是如何保证的

事务的隔离性通过<font color="red">锁和多版本并发控制（MVCC）</font>来保证



## 3-5-MVCC

### 3-5-1-概念

- MVCC 是一种并发控制机制，用于在多个并发事务同时读写数据库时，保持数据的<font color="red">一致性和隔离性</font>
- 通过创建数据的<font color="red">多个版本和使用快照读取</font>来实现并发控制
- 读操作：
    - 使用<font color="red">快照读取</font>。快照读取是基于事务开始时数据库中的状态创建的，因此其他并发事务对数据行的修改不会影响当前事务的读取操作
- 写操作：
    - 事务为要修改的数据行创建一个<font color="red">新的版本</font>，并将修改后的数据写入新版本
    - 新版本的数据会带有当前事务的<font color="red">版本号</font>，以便其他事务能够正确读取相应版本的数据
    - 原始版本的数据仍然存在，供其他事务使用快照读取，这保证了其他事务不受当前事务的<font color="red">写操作影响</font>



### 3-5-2-InnoDB 对 MVCC的实现

`MVCC` 的实现<font color="red">依赖</font>于：**隐藏字段、Read View、undo log**。在内部实现中，`InnoDB` 通过数据行的 `DB_TRX_ID` 和 `Read View` 来判断数据的可见性，如不可见，则通过数据行的 `DB_ROLL_PTR` 找到 `undo log` 中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建 `Read View` 之前已经提交的修改和该事务本身做的修改



#### 3-5-1-1-隐藏字段

在内部，`InnoDB` 存储引擎为每行数据添加了三个隐藏字段

- `DB_TRX_ID（6字节）`：表示最后一次插入或更新该行的事务 id。此外，`delete` 操作在内部被视为更新，只不过会在记录头 `Record header` 中的 `deleted_flag` 字段将其标记为已删除
- `DB_ROLL_PTR（7字节）` 回滚指针，指向该行的 `undo log` 。如果该行未被更新，则为空
- `DB_ROW_ID（6字节）`：如果没有设置主键且该表没有唯一非空索引时，`InnoDB` 会使用该 id 来生成聚簇索引



#### 3-5-1-2-Read View

Read View主要是用来做<font color="red">可见性判断</font>，里面保存了 “当前对本事务不可见的其他活跃事务”

主要有以下字段：

- `m_low_limit_id`：目前出现过的最大的事务 ID+1，即下一个将被分配的事务 ID。大于等于这个 ID 的数据版本均不可见
- `m_up_limit_id`：活跃事务列表 `m_ids` 中最小的事务 ID，如果 `m_ids` 为空，则 `m_up_limit_id` 为 `m_low_limit_id`。小于这个 ID 的数据版本均可见
- `m_ids`：`Read View` 创建时其他未提交的活跃事务 ID 列表。创建 `Read View`时，将当前未提交事务 ID 记录下来，后续即使它们修改了记录行的值，对于当前事务也是不可见的。`m_ids` 不包括当前事务自己和已提交的事务（正在内存中）
- `m_creator_trx_id`：创建该 `Read View` 的事务 ID

![image-20250519131058877](https://picgo-zjp.oss-cn-shenzhen.aliyuncs.com/image-20250519131058877.png)



##### 3-5-1-2-1-数据可见性算法

1. 如果记录 DB_TRX_ID < m_up_limit_id，那么表明最新修改该行的事务（DB_TRX_ID）在当前事务创建快照之前就提交了，所以该记录行的值对当前事务是可见的
2. 如果 DB_TRX_ID >= m_low_limit_id，那么表明最新修改该行的事务（DB_TRX_ID）在当前事务创建快照之后才修改该行，所以该记录行的值对当前事务不可见。跳到步骤 5
3. m_ids 为空，则表明在当前事务创建快照之前，修改该行的事务就已经提交了，所以该记录行的值对当前事务是可见的
4. 如果 m_up_limit_id <= DB_TRX_ID < m_low_limit_id，表明最新修改该行的事务（DB_TRX_ID）在当前事务创建快照的时候可能处于“活动状态”或者“已提交状态”；所以就要对活跃事务列表 m_ids 进行查找（源码中是用的二分查找，因为是有序的）
    - 如果在活跃事务列表 m_ids 中能找到 DB_TRX_ID，表明：① 在当前事务创建快照前，该记录行的值被事务 ID 为 DB_TRX_ID 的事务修改了，但没有提交；或者 ② 在当前事务创建快照后，该记录行的值被事务 ID 为 DB_TRX_ID 的事务修改了。这些情况下，这个记录行的值对当前事务都是不可见的。跳到步骤 5
    - 在活跃事务列表中找不到，则表明“id 为 trx_id 的事务”在修改“该记录行的值”后，在“当前事务”创建快照前就已经提交了，所以记录行对当前事务可见
5. 在该记录行的 DB_ROLL_PTR 指针所指向的 `undo log` 取出快照记录，用快照记录的 DB_TRX_ID 跳到步骤 1 重新开始判断，直到找到满足的快照版本或返回空



#### 3-5-1-3-undo log

`undo log` 主要有两个作用：

- 当<font color="red">事务回滚</font>时用于将数据恢复到修改前的样子
- 另一个作用是 <font color="red">`MVCC` </font>，当读取记录时，若该记录被其他事务占用或当前版本对该事务不可见，则可以通过 `undo log` 读取之前的版本数据，以此实现<font color="red">非锁定读</font>



## 3-6-RC 和 RR 隔离级别下 MVCC 的差异

在事务隔离级别 `RC` 和 `RR` （InnoDB 存储引擎的默认事务隔离级别）下，`InnoDB` 存储引擎使用 `MVCC`（非锁定一致性读），但它们<font color="red">生成 `Read View` 的时机却不同</font>

- 在 RC 隔离级别下的 **`每次select`** 查询前都生成一个`Read View` (m_ids 列表)
- 在 RR 隔离级别下只在事务开始后 **`第一次select`** 数据前生成一个`Read View`（m_ids 列表）



## 3-7-MVCC + Next-key-Lock 防止幻读

`InnoDB`存储引擎在 RR 级别下通过 `MVCC`和 `Next-key Lock` 来解决幻读问题：

1. 执行普通 `select`，此时会以 `MVCC` 快照读的方式读取数据：
    - 在快照读的情况下，RR 隔离级别只会在事务开启后的第一次查询生成 `Read View` ，并使用至事务提交。所以在生成 `Read View` 之后其它事务所做的更新、插入记录版本对当前事务并不可见，实现了可重复读和防止快照读下的 “幻读”
2. 执行 select...for update/lock in share mode、insert、update、delete 等当前读（也称锁定读，会读取的数据加锁）：
    - 在当前读下，读取的都是最新的数据，如果其它事务有插入新的记录，并且刚好在当前事务查询范围内，就会产生幻读！`InnoDB` 使用 Next-key Lock 来防止这种情况。当执行当前读时，会锁定读取到的记录的同时，锁定它们的间隙，防止其它事务在查询范围内插入数据。只要我不让你插入，就不会发生幻读



## 3-8-什么是XA协议

![image-20250510153306112](https://picgo-zjp.oss-cn-shenzhen.aliyuncs.com/image-20250510153306112.png)

- AP（Application Program）：应用程序，定义事务边界（定义事务开始和结束）并访问事务边界内的资源
- RM（Resource Manger）资源管理器: 管理共享资源并提供外部访问接口。供外部程序来访问数据库等共享资源。此外，RM还具有事务的回滚能力
- TM（Transaction Manager）事务管理器：TM是分布式事务的协调者，TM与每个RM进行通信，负责管理全局事务，分配事务唯一标识，监控事务的执行进度，并负责事务的提交、回滚、失败恢复等



- 应用程序AP向事务管理器TM发起事务请求
- TM调用xa_open()建立同资源管理器的会话
- TM调用xa_start()标记一个事务分支的开头
- AP访问资源管理器RM并定义操作，比如插入记录操作
- TM调用xa_end()标记事务分支的结束
- TM调用xa_prepare()通知RM做好事务分支的提交准备工作。其实就是二阶段提交的提交请求阶段。
- TM调用xa_commit()通知RM提交事务分支，也就是二阶段提交的提交执行阶段。
- TM调用xa_close管理与RM的会话。
    - 这些接口一定要按顺序执行，比如xa_start接口一定要在xa_end之前。此外，这里千万要注意的是事务管理器只是标记事务分支并不执行事务，事务操作最终是由应用程序通知资源管理器完成的。另外，我们来总结下XA的接口
- xa_start:负责开启或者恢复一个事务分支，并且管理XID到调用线程
- xa_end:负责取消当前线程与事务分支的关系
- xa_prepare:负责询问RM 是否准备好了提交事务分支 xa_commit:通知RM提交事务分支
- xa_rollback:通知RM回滚事务分支



## 3-9-是否使用过select for update

==select本身是一个查询语句，查询语句是不会产生冲突的一种行为，一般情况下是没有锁的，用select for update 会让select语句产生一个排它锁(X), 这个锁和update的效果一样，会使两个事务无法同时更新一条记录==

- for update仅适用于InnoDB，且必须在事务块(BEGIN/COMMIT)中才能生效

- 在进行事务操作时，通过“for update”语句，MySQL会对查询结果集中每行数据都添加排他锁，其他线程对该记录的更新与删除操作都会阻塞。排他锁包含行锁、表锁
- InnoDB默认是行级别的锁，在筛选条件中当有明确指定主键或唯一索引列的时候，是行级锁。否则是表级别



# 4-锁

## 4-1-表级锁和行级锁有什么区别

表级锁：串行化（serializable）时，整表加锁，事务访问表数据时需要申请锁，虽然可分为读锁和写锁，但毕竟是锁住整张表，会导致<font color="red">并发能力</font>下降，一般是做ddl处理时使用

行级锁：除了串行化（serializable）时 InnoDB使用的都是行级锁，只锁一行数据，其他行数据不影响，并发能力强



## 4-2-什么是行级锁？Mysql如何完成的

行级锁实现比较复杂不是单纯锁住一行数据，是由mvcc完成的



## 4-3-什么是共享锁（读锁）

共享锁或S锁，其它事务可以继续加共享锁，但不能加排它锁



## 4-4-什么是排它锁（写锁/独占锁）

排它锁或X锁，在进行写操作之前要申请并获得，其它事务不能再获得任何锁



## 4-5-什么是意向锁

它分为意向共享锁（IS）和意向排他锁（IX）

一个事务对一张表的某行添加共享锁前，必须获得对该表一个IS锁或者优先级更高的锁。
一个事务对一张表的某行添加排他锁之前，它必须对该表获取一个IX锁。

意向锁属于表锁，它不与innodb中的行锁冲突，任意两个意向锁之间也不会产生冲突，但是会与表锁（S锁和X锁）产生冲突



## 4-6-InnoDB支持哪几种锁

表锁，行锁，间隙锁，Next-Key锁等

在Serializable中读加共享锁，写加排他锁，读写互斥

两段锁协议，将事务分成两个阶段，加锁阶段和解锁阶段（所以叫两段锁）



## 4-7-当前读和快照读分别是什么

当前读 ：在锁定读（使用锁隔离事物）的时候读到的是<font color="red">最新</font>版本的数据

快照读：可重复读（repeatable-read）下 mvcc生效读取的是数据的<font color="red">快照</font>，并不是最新版本的数据（未提交事物的数据）



# 5-存储引擎

## 5-1-MySQL 支持哪些存储引擎

| 特点         | InnoDB           | MyISAM | Memory |
| ------------ | ---------------- | ------ | ------ |
| 存储限制     | 64TB             | 有限制 | 有限制 |
| 事务安全     | 支持             | -      | -      |
| 锁机制       | 行锁             | 表锁   | 表锁   |
| B+tree索引   | 支持             | 支持   | 支持   |
| Hash索引     | -                | -      | 支持   |
| 全文索引     | 支持(5.6版本之后 | 支持   | -      |
| 空间使用     | 高               | 低     | N/A    |
| 内存使用     | 高               | 低     | 中等   |
| 批量插入速度 | 低               | 高     | 高     |
| 支持外键     | 支持             | -      | -      |



## 5-2-MySQL 存储引擎架构了解吗

InnoDB引擎结构图，主要分为<font color="red">内存结构和磁盘结构</font>两大部分：

![image-20250510104406387](https://picgo-zjp.oss-cn-shenzhen.aliyuncs.com/image-20250510104406387.png)

- **内存区域**：
    - **Buffer Pool**:在InnoDB访问表记录和索引时会在Buffer Pool的页中缓存，以后使用可以减少磁盘IO操作，提升效率。主要用来缓存热的数据页和索引页
    - **Log Buffer**：用来缓存redo log
    - **Adaptive Hash Index**：自适应哈希索引
    - **Change Buffer**:它是一种应用在非唯一普通索引页（non-unique secondary index page）不在缓冲池中，对页进行了写操作，并不会立刻将磁盘页加载到缓冲池，而仅仅记录缓冲变更（Buffer Changes），等未来数据被读取时，再将数据合并（Merge）恢复到缓冲池中的技术。写缓冲的目的是降低写操作的磁盘IO，提升数据库性能

- **磁盘区域**
    - 表空间：分为系统表空间(MySQL 目录的 ibdata1 文件)，临时表空间，常规表空间，Undo 表空间以及 file-per-table 表空间(MySQL5.7默认打开file_per_table 配置）。系统表空间又包括了InnoDB数据字典，双写缓冲区(Doublewrite Buffer)，修改缓存(Change Buffer），Undo日志等
    - Redo日志：存储的就是 Log Buffer 刷到磁盘的数据



## 5-3-MyISAM 和 InnoDB 的区别是什么

外键 事务 锁

| **对比项**     | **MyISAM**                                               | **InnoDB**                                                   |
| -------------- | -------------------------------------------------------- | ------------------------------------------------------------ |
| 外键           | 不支持                                                   | 支持                                                         |
| 事务           | 不支持                                                   | 支持                                                         |
| 行表锁         | 表锁，即使操作一条记录也会锁住整个表，不适合高并发的操作 | 行锁，操作时只锁某一行，不对其它行有影响，适合高并发的操作   |
| 缓存           | 只缓存索引，不缓存真实数据                               | 不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响 |
| 关注点         | 并发查询，节省资源、消耗少、简单业务                     | 并发写、事务、多表关系、更大资源                             |
| 默认安装       | Y                                                        | Y                                                            |
| 默认使用       | N                                                        | Y                                                            |
| 自带系统表使用 | Y                                                        | N                                                            |



# 6-读写分离

## 6-1-MySQL主从同步原理是什么

MySQL主从复制的核心是二进制日志（Binlog）。步骤如下：

1. 主库在事务提交时，记录数据变更到 Binlog
2. 从库读取主库的 Binlog 并写入<font color="red">中继日志</font>（Relay Log）
3. 从库重做中继日志中的事件，反映到自己的数据中



# 7-分库分表



# 8-内部架构

## 8-1-Mysql内部支持缓存查询吗

当MySQL接收到客户端的查询SQL之后，仅仅只需要对其进行相应的权限验证之后，就会通过Query Cache来查找结果，甚至都不需要经过Optimizer模块进行执行计划的分析优化，更不需要发生任何存储引擎的交互

mysql5.7支持内部缓存，8.0之后就废弃掉了



## 8-2-mysql 8为何废弃掉查询缓存

缓存的意义在于快速查询提升系统性能，可以灵活控制缓存的一致性

mysql缓存的限制

1. mysql基本没有手段灵活的**管理**缓存失效和生效，尤其对于频繁更新的表
2. SQL必须<font color="red">完全一致</font>才会导致cache命中
3. 为了<font color="red">节省内存空间</font>，太大的result set不会被cache (< query_cache_limit)
4. MySQL缓存在<font color="red">分库分表</font>环境下是不起作用的
6. 在表的<font color="red">结构或数据</font>发生改变时，基于该表相关cache立即全部失效



## 8-3-Mysql内部有哪些核心模块组成，作用是什么

![image-20250510101324504](https://picgo-zjp.oss-cn-shenzhen.aliyuncs.com/image-20250510101324504.png)

![image-20250510101347162](https://picgo-zjp.oss-cn-shenzhen.aliyuncs.com/image-20250510101347162.png)

连接层、服务层、引擎层和存储层



## 8-4-SQL语句在MySQL中的执行过程

![image-20250510101944685](https://picgo-zjp.oss-cn-shenzhen.aliyuncs.com/image-20250510101944685.png)

![image-20250510102251937](https://picgo-zjp.oss-cn-shenzhen.aliyuncs.com/image-20250510102251937.png)

### 8-4-1-MySQL 基本架构概览

![image-20250519164228047](https://picgo-zjp.oss-cn-shenzhen.aliyuncs.com/image-20250519164228047.png)

- **Server 层**：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 binlog 日志模块

    - **连接器：** 身份认证和权限相关(登录 MySQL 的时候)
    - **查询缓存：** 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）
    - **分析器：** 进行词法分析和语法分析，没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确
    - **优化器：** 按照 MySQL 认为最优的方案去执行
    - **执行器：** 执行语句，然后从存储引擎返回数据

- **存储引擎**：主要负责数据的存储和读取，采用可以替换的插件式架构，支持 InnoDB、MyISAM、Memory 等多个存储引擎，其中 InnoDB 引擎有自有的日志模块 redolog 模块。**现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5 版本开始就被当做默认存储引擎了**

    

### 8-4-2-查询语句

1. 先检查该语句<font color="red">是否有权限</font>，如果没有权限，直接返回错误信息，如果有权限，在 MySQL8.0 版本以前，会先<font color="red">查询缓存</font>，以这条 SQL 语句为 key 在内存中查询是否有结果，如果有直接缓存，如果没有，执行下一步
2. 分析器进行语句解析
    - <font color="red">词法分析</font>，提取 SQL 语句的关键元素，如表名、字段名、关键字等
    - <font color="red">语法分析</font>,判断这个 SQL 语句是否有语法错误，比如关键词是否正确等等，如果检查没问题就执行下一步
3. <font color="red">优化器</font>确定执行方案
    - 根据表的索引、统计信息等生成多种可能的执行计划
    - 根据内部成本估算模型选择一条“成本最小”的执行计划（不一定是最优，但是优化器认为最优的）
    - 执行计划生成后，交由执行器调度执行
4. 进行<font color="red">权限校验</font>，如果没有权限就会返回错误信息，如果有权限就会调用<font color="red">数据库引擎接口</font>，返回引擎的执行结果
    - MySQL 中数据是以页为单位，你查询一条记录，会从硬盘把一页的数据加载出来，加载出来的数据叫数据页，会放入到<font color="red"> `Buffer Pool` </font>中
    - 后续的查询都是先从 `Buffer Pool` 中找，没有命中再去硬盘加载，减少硬盘 IO 开销，提升性能



### 8-4-3-修改语句

1. 先检查该语句<font color="red">是否有权限</font>，如果没有权限，直接返回错误信息；有权限进行下一步操作
2. 分析器进行语句解析
    - <font color="red">词法分析</font>，提取 SQL 语句的关键元素，如表名、字段名、关键字等
    - <font color="red">语法分析</font>,判断这个 SQL 语句是否有语法错误，比如关键词是否正确等等，如果检查没问题就执行下一步
3. <font color="red">优化器</font>确定执行方案
    - 根据表的索引、统计信息等生成多种可能的执行计划
    - 根据内部成本估算模型选择一条“成本最小”的执行计划（不一定是最优，但是优化器认为最优的）
    - 执行计划生成后，交由执行器调度执行
4. 调用<font color="red">数据库引擎接口</font>

    - 数据加载
        - 当执行修改语句时，目标数据页若不在内存中的 `Buffer Pool`，会先从磁盘加载到 `Buffer Pool`
        - 在 `Buffer Pool` 中对数据页进行修改（内存中修改，不是直接改磁盘）
    - 事务执行期间
        - `redo log buffer` 和 `undo log` 由存储引擎持续写入，保证物理数据修改的持久性和可回滚性
        - Server 层将执行的更新语句或对应的行变更操作写入内存中的 `binlog cache`（逻辑日志缓存）
    - 事务提交阶段（刷盘与两阶段提交）
        - 存储引擎根据`redo log`的刷盘策略（事务提交时或者缓存空间不足等），将 `redo log buffer` 中的日志刷盘到磁盘的 `redo log` 文件，状态变为 `prepare`（预提交）
        - Server 层将 `binlog cache` 中的逻辑日志刷盘到 `binlog` 文件中，成为永久日志，支持主从复制和恢复
        - 当 `binlog` 刷盘成功后，Server 通知存储引擎将 `redo log` 状态从 `prepare` 切换到 `commit`
        - 此时，事务正式提交完成。MySQL 通过 **WAL（Write-Ahead Logging）+ 两阶段提交（2PC）** 机制，保证 `binlog` 与 `redo log` 的数据一致性



## 8-5- MySQL 提示“不存在此列”是执行到哪个节点报出的

在Parser：解析器 分析sql语法的时候检查的列



## 8-6-如果一张表创建了多个索引，在哪个阶段或模块进行的索引选择

在优化器阶段Optimizer：查询优化器



# 9-日志

## 9-1-Mysql会产生几种日志

| 日志                         | 说明                                          |
| ---------------------------- | --------------------------------------------- |
| 错误日志（error log）        | 记录MySQL在启动、关闭或者运行过程中的错误信息 |
| 慢查询日志（slow query log） | 记录在MySQL中响应时间超过阀值的语句           |
| 重写日志（redo log）         | 如下                                          |
| 回滚日志（undo log）         | 如下                                          |
| 二进制日志（bin log）        | 如下                                          |

| 类型         | 所属组件            | 作用                                                         | 持久化时机           | 物理/逻辑 | 是否参与崩溃恢复 |
| ------------ | ------------------- | ------------------------------------------------------------ | -------------------- | --------- | ---------------- |
| **redo log** | InnoDB              | 用于**崩溃恢复**，实现 WAL（先写日志）机制，确保事务提交后数据不丢 | 事务提交前写入磁盘   | 物理日志  | ✅ 是             |
| **undo log** | InnoDB              | 用于**事务回滚** 和 **MVCC 快照读**，存储修改前的旧值        | 随事务执行生成       | 逻辑日志  | ✅ 是             |
| **binlog**   | Server 层（全引擎） | 用于**主从复制**、**数据恢复**，记录所有对数据的修改操作（DML/DDL） | 事务提交时一次性写入 | 逻辑日志  | ❌ 否             |



## 9-2-redo log

### 9-2-1-作用

- redo log（重做日志）是 InnoDB 存储引擎<font color="red">独有</font>的，是<font color="red">物理日志</font>，让 MySQL 拥有了崩溃恢复能力
- 记录的是数据页的物理变化，用于服务宕机后的恢复，保证事务的<font color="red">持久性</font>



### 9-2-2-刷盘时机

![image-20250519184605469](https://picgo-zjp.oss-cn-shenzhen.aliyuncs.com/image-20250519184605469.png)

- MySQL 中数据是以页为单位，你查询一条记录，会从硬盘把一页的数据加载出来，加载出来的数据叫数据页，会放入到 `Buffer Pool` 中

- 后续的查询都是先从 `Buffer Pool` 中找，没有命中再去硬盘加载，减少硬盘 IO 开销，提升性能

- 更新表数据的时候，也是如此，发现 `Buffer Pool` 里存在要更新的数据，就直接在 `Buffer Pool` 里更新

- 然后会把“在某个数据页上做了什么修改”记录到重做日志缓存（`redo log buffer`）里，接着刷盘到 `redo log` 文件里



InnoDB 将 `redo log` 刷到磁盘上有几种情况：

1. <font color="red">事务提交</font>：当事务提交时，log buffer 里的 redo log 会被刷新到磁盘（可以通过`innodb_flush_log_at_trx_commit`参数控制）
2. <font color="red">log buffer 空间不足</font>时：log buffer 中缓存的 redo log 已经占满了 log buffer 总容量的大约一半左右，就需要把这些日志刷新到磁盘上
3. <font color="red">事务日志缓冲区</font>满：InnoDB 使用一个事务日志缓冲区（transaction log buffer）来暂时存储事务的重做日志条目。当缓冲区满时，会触发日志的刷新，将日志写入磁盘
4. Checkpoint（检查点）：InnoDB 定期会执行检查点操作，将内存中的脏数据（已修改但尚未写入磁盘的数据）刷新到磁盘，并且会将相应的重做日志一同刷新，以确保数据的一致性
5. <font color="red">后台刷新线程</font>：InnoDB 启动了一个后台线程，负责周期性（每隔 1 秒）地将脏页（已修改但尚未写入磁盘的数据页）刷新到磁盘，并将相关的重做日志一同刷新
6. <font color="red">正常关闭服务器</font>：MySQL 关闭的时候，redo log 都会刷入到磁盘里去

总之，InnoDB 在多种情况下会刷新重做日志，以保证数据的持久性和一致性



`innodb_flush_log_at_trx_commit` 的值有 3 种，也就是共有 3 种刷盘策略：

- **0**：设置为 0 的时候，表示每次事务提交时不进行刷盘操作。这种方式性能最高，但是也最不安全，因为如果 MySQL 挂了或宕机了，可能会丢失最近 1 秒内的事务
- **1**：设置为 1 的时候，表示每次事务提交时都将进行刷盘操作。这种方式性能最低，但是也最安全，因为只要事务提交成功，`redo log` 记录就一定在磁盘里，不会有任何数据丢失
- **2**：设置为 2 的时候，表示每次事务提交时都只把 `log buffer` 里的 `redo log` 内容写入 `page cache`（文件系统缓存）。`page cache` 是专门用来缓存文件的，这里被缓存的文件就是 `redo log` 文件。这种方式的性能和安全性都介于前两者中间

刷盘策略`innodb_flush_log_at_trx_commit` 的默认值为 1，设置为 1 的时候才不会丢失任何数据。为了保证事务的持久性，我们必须将其设置为 1



另外，InnoDB 存储引擎有一个后台线程，每隔`1` 秒，就会把 `redo log buffer` 中的内容写到文件系统缓存（`page cache`），然后调用 `fsync` 刷盘

![image-20250519185712820](https://picgo-zjp.oss-cn-shenzhen.aliyuncs.com/image-20250519185712820.png)



## 9-3-undo log作用是什么

- undo log记录的是<font color="red">逻辑日志</font>，记录的是 SQL 语句，用于事务回滚时恢复原始数据，保证事务的<font color="red">原子性和一致性</font>
- <font color="red">MVCC</font>的实现依赖于：隐藏字段、undo log、Read View



## 9-4-binlog

### 9-4-1-作用

- 二进制日志（BINLOG）它是<font color="red">逻辑日志</font>，记录了所有的 DDL（数据定义语言）语句和 DML（数据操纵语言）语句，但不包括数据查询（SELECT、SHOW）语句


- bin log最大的用处就是进行<font color="red">主从复制</font>，以及<font color="red">数据库的恢复</font>



### 9-4-2-记录格式

binlog 日志有三种格式，可以通过`binlog_format`参数指定

- **statement**：记录的内容是`SQL`语句原文，比如执行一条`update T set update_time=now() where id=1`
- **row**
- **mixed**



### 9-4-3-写入机制

事务执行过程中，先把日志写到`binlog cache`，事务提交的时候，再把`binlog cache`写到 `binlog` 文件中



## 9-5-Mysql日志是否实时写入磁盘

| 日志类型     | 是否实时写盘             | 刷盘控制参数                       | 完善说明                                                     |
| ------------ | ------------------------ | ---------------------------------- | ------------------------------------------------------------ |
| **redo log** | 否（默认延迟）           | `innodb_flush_log_at_trx_commit`   | InnoDB 的重做日志，用于**崩溃恢复**，记录已提交事务对数据页的修改；写入 redo log buffer 后根据策略刷盘，**事务提交时是否立即落盘取决于参数**，默认值 `1` 表示每次提交都刷盘（强一致性），可提升数据安全性 |
| **undo log** | 否                       | 无需专门刷盘参数（与数据页一起刷） | InnoDB 的回滚日志，用于**事务回滚和 MVCC 版本控制**，不单独立即刷盘，而是随着数据页由后台线程定期写入磁盘；**刷盘机制依赖 InnoDB 的脏页刷新策略** |
| **binlog**   | 否（默认不实时，需配置） | `sync_binlog`                      | Server 层的二进制日志，用于**主从复制、数据恢复、审计**；事务提交时一次性写入，是否立即刷盘取决于 `sync_binlog` 设置，`1` 表示每次提交强制刷盘，**保障主从一致性**，但对性能有一定影响 |



## 9-6-Mysql集群同步时为什么使用binlog

| 分类                                 | 内容                                                         |
| ------------------------------------ | ------------------------------------------------------------ |
| 📘 **定义**                           | binlog（二进制日志）是 **MySQL Server 层生成的逻辑日志**，记录的是对数据库执行的增删改等操作，不包含查询语句，不依赖具体存储引擎。所有存储引擎都支持。 |
| 🧩 **主从复制核心机制**               | MySQL 主从复制通过 binlog 实现。主库将 binlog 写入磁盘，从库通过 I/O 线程读取 binlog 并重放，确保主从数据一致。 |
| ✅ **优势一：逻辑清晰、可重放**       | binlog 记录的是 SQL 语句或行级变更（row-based），便于按顺序回放操作，确保一致性。 |
| ✅ **优势二：增量同步支持**           | binlog 持续记录事务操作，支持从断点 offset 处恢复同步，便于断点续传，减少全量复制开销。 |
| ✅ **优势三：与中间件集成**           | binlog 可被 Canal、Maxwell、Debezium 等中间件读取，实现数据同步到 Kafka、HDFS、Elasticsearch 等系统。 |
| ✅ **优势四：跨版本与跨实例兼容性好** | 与 redo log 不同，binlog 是逻辑日志，不依赖底层存储结构，适合不同版本、不同实例间复制。 |
| ⚠️ **为什么不用 redo / undo**         | redo/undo 是 InnoDB 的物理日志，只在本地用于恢复和事务管理，不具备跨实例同步能力。 |
| ❌ **复制表文件的问题**               | 复制 .ibd 或 .frm 等数据文件不能保障事务一致性，也不支持按时间点恢复；复制中断后很难确定复制位置，数据一致性不可控。 |



# 10-开发经验

## 10-1-日期，时间如何存取

在 MySQL 中，存储日期时间通常使用内建的时间类型，而非字符串。常见的时间类型有：

| 类型        | 存储字节 | 支持范围                                           | 精度（MySQL 5.6+ 支持小数秒） | 是否受时区影响 |
| ----------- | -------- | -------------------------------------------------- | ----------------------------- | -------------- |
| `DATE`      | 3 字节   | 1000-01-01 到 9999-12-31                           | 无                            | 否             |
| `TIME`      | 3 字节   | -838:59:59 到 838:59:59                            | 支持                          | 否             |
| `DATETIME`  | 8 字节   | 1000-01-01 00:00:00 到 9999-12-31 23:59:59         | 支持                          | 否             |
| `TIMESTAMP` | 4 字节   | 1970-01-01 00:00:01 UTC 到 2038-01-19 03:14:07 UTC | 支持                          | ✅ 是           |

`TIMESTAMP` vs `DATETIME` 的区别：

| 比较点         | `TIMESTAMP`                        | `DATETIME`                         |
| -------------- | ---------------------------------- | ---------------------------------- |
| 存储方式       | 存储为 UTC 时间戳（整数）          | 以字符串格式存储完整时间           |
| 显示方式       | 显示为当前时区下的本地时间         | 显示为录入时的时间，无时区转换     |
| 是否受时区影响 | ✅ 是（插入/查询会自动转换）        | ❌ 否（固定值，时区变化无影响）     |
| 占用空间       | ✅ 较小（4 字节）                   | ⛔ 较大（8 字节）                   |
| 推荐用途       | 存储**时间戳、记录变更时间**等     | 存储**绝对时间，如生日、事件时间** |
| 2038 问题      | 有（最大值受限于 Unix 时间戳范围） | 无（范围远大）                     |

为什么不建议使用字符串存储日期时间

- **空间浪费**：字符串如 `"2024-05-10 13:45:00"` 占用至少 19 字节，而 `DATETIME` 只需 8 字节
- **效率低**：字符串不支持高效的范围查询、排序、索引，查询性能差
- **语义不清晰**：字符串容易录入错误或格式不一致，如 `"2024/5/10"`、`"10-05-2024"`
- **无法进行时间计算**：字符串不能直接进行加减、间隔计算等，需要先转换格式



## 10-2-需要使用时间戳 timestamp和int该如何选择

| 比较项             | `TIMESTAMP`                                           | `INT`（存储 Unix 时间戳，如 `INT(10)`）     |
| ------------------ | ----------------------------------------------------- | ------------------------------------------- |
| **存储格式**       | 内部以 Unix 时间戳存储，显示为日期时间格式            | 存储为整数（单位：秒）                      |
| **可读性**         | ✅ 自动转为 `YYYY-MM-DD hh:mm:ss`，人类可读            | ❌ 需手动转换（如 `FROM_UNIXTIME()`）        |
| **自动处理时区**   | ✅ 会自动根据时区进行转换                              | ❌ 不处理时区                                |
| **自动初始化**     | ✅ 可使用 `DEFAULT CURRENT_TIMESTAMP` 自动写入当前时间 | ❌ 不支持自动写入当前时间                    |
| **存储空间**       | ✅ 4 字节（MySQL 5.6+ 可带小数秒）                     | ✅ 4 字节（也可用 `BIGINT` 存毫秒）          |
| **最大表示范围**   | ⛔ 到 2038-01-19（32 位 Unix 时间戳）                  | ✅ 最大可表示 `2147483647`（约2038年）或更大 |
| **时间计算**       | ✅ 可直接进行时间间隔、函数处理                        | ❌ 需转为时间格式才能进行计算                |
| **是否受时区影响** | ✅ 受时区影响                                          | ❌ 不受时区影响                              |



## 10-3-char与varchar的区别？如何选择

| 项目             | `CHAR`                                 | `VARCHAR`                                  |
| ---------------- | -------------------------------------- | ------------------------------------------ |
| **存储方式**     | **定长**，不足部分用空格填充           | **变长**，按实际长度存储 +1/2 字节记录长度 |
| **性能**         | ✅ 查询更快，存取效率高                 | ❌ 查询稍慢，存取需额外处理长度信息         |
| **空间利用**     | ❌ 占用空间固定，浪费存储               | ✅ 空间利用高，节省存储                     |
| **更新开销**     | ✅ 更新不容易引起页分裂                 | ❌ 更新可能引起页分裂（行变长）             |
| **最大长度**     | 0 ~ 255 字节                           | 最多可达 65535 字节（受行大小约束）        |
| **适合字段**     | 长度固定，如身份证、手机号、国家代码等 | 长度不定，如姓名、地址、备注、描述等       |
| **尾部空格处理** | 查询时会**自动去除尾部空格**           | 查询保留空格，比较需注意                   |

| 场景                                         | 建议类型    | 原因说明                                   |
| -------------------------------------------- | ----------- | ------------------------------------------ |
| 存储长度固定的字符串（如身份证号、邮政编码） | ✅ `CHAR`    | 查询速度快，占用空间稳定，无需存储长度信息 |
| 存储长度不定的字符串（如备注、标题、地址）   | ✅ `VARCHAR` | 更节省空间，适应长度变化                   |
| 表设计追求极致读性能                         | ✅ `CHAR`    | 定长字段对查询优化有利                     |
| 表更新频繁，字段长度经常变化                 | ✅ `CHAR`    | 避免页分裂，提高更新效率                   |
| 存储大量变长文本（如评论、内容）             | ✅ `VARCHAR` | 结合合适字段长度设置，节约存储空间         |



## 10-4-财务计算有没有出现过错乱

| 类别            | 问题描述                               | 常见原因 / 场景                                              | 解决方案 / 实践建议                                          |
| --------------- | -------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **并发问题**    | 多线程或多用户操作导致数据不一致       | - 多线程共享变量无同步- 用户操作提交前 UI 超时- 并发提交订单等 | - 使用线程安全的数据结构或加锁机制- 控制提交超时策略- 数据库加 **悲观锁**：`SELECT ... FOR UPDATE` |
| **精度问题**    | 浮点运算误差、金额计算不准确           | - 使用 `float` / `double` 进行金额计算- 除法精度丢失         | - 使用 `BigDecimal` 或数据库中的 `DECIMAL` 类型- 用乘法代替除法（避免除不尽） |
| **事务问题**    | 部分操作提交失败导致状态不一致         | - 未开启事务或事务范围错误- 异常未回滚- 跨多库事务失败       | - 使用数据库事务确保 **ACID** 特性- 明确控制提交与回滚时机   |
| **数据删除**    | 数据被误删或不可恢复                   | - 直接物理删除导致无法审计- 操作误删记录                     | - 使用**逻辑删除**（设置删除标识位）- 审计字段记录操作人和时间 |
| **审计追溯**    | 出现错误后无法还原或定位问题           | - 日志不全- 操作无记录- 账务数据无快照或对账信息             | - 记录详细日志（操作日志、变更记录）- 保留历史数据快照或账务流水备份 |
| **UI 提交问题** | 用户在界面操作未及时提交或提交状态混乱 | - 会话过期- 表单重复提交- 未判断前端状态                     | - 设置前端防抖与唯一 token 限制重复提交- 后端校验请求有效性  |



## 10-5-decimal与float,double的区别是什么

| 项目                  | `DECIMAL`（定点数）                                  | `FLOAT`（单精度浮点）                            | `DOUBLE`（双精度浮点）                               |
| --------------------- | ---------------------------------------------------- | ------------------------------------------------ | ---------------------------------------------------- |
| **存储方式**          | 以字符串形式存储，精确表示十进制                     | 以二进制浮点存储（IEEE 754）                     | 以二进制浮点存储（IEEE 754）                         |
| **精度**              | ✅ 精度高，完全无误差，适合财务等场景                 | ❌ 存在精度误差，易出现四舍五入等问题             | ❌ 精度比 FLOAT 高，但仍有误差                        |
| **适用场景**          | 金额、财务、精确计算，如银行、电商交易               | 科学计算、图像处理、临时计算等对精度要求不高场景 | 对精度要求高于 float，但仍可容忍小误差的科学计算场景 |
| **计算性能**          | ❌ 较慢（精度换来的代价）                             | ✅ 计算速度快                                     | ✅ 较快                                               |
| **存储空间（MySQL）** | 可指定精度，如 `DECIMAL(10,2)`，每 9 位数字约 4 字节 | 4 字节                                           | 8 字节                                               |
| **是否建议用于金额**  | ✅ 推荐（避免误差）                                   | ❌ 不推荐                                         | ❌ 不推荐                                             |



## 10-6-预编译sql是什么

SQL 预编译就是先将 SQL 结构发送给数据库编译好，后续只需传递参数即可执行

**优点**

| 优点                 | 说明                                              |
| -------------------- | ------------------------------------------------- |
| **防止 SQL 注入**    | 参数不拼接在 SQL 中，而是绑定传入，避免恶意注入。 |
| **提升性能**         | SQL 结构只编译一次，后续复用执行计划，效率更高。  |
| **节省网络传输成本** | 参数单独传送，减少字符串拼接体积和解析开销。      |



## 10-7-子查询与join哪个效率高

**通常情况下，`JOIN` 比子查询效率高**，因为 JOIN 允许数据库优化器采用更优的执行计划，而子查询（尤其是嵌套子查询）往往执行顺序固定、难以优化

| 比较项       | 子查询                         | JOIN                               |
| ------------ | ------------------------------ | ---------------------------------- |
| **执行机制** | 通常先执行内层子查询，再外层   | 优化器可选择执行顺序、构建连接方式 |
| **优化空间** | 优化器难以改写嵌套子查询       | 优化器可自由调度 JOIN 的执行顺序   |
| **中间结果** | 子查询可能生成临时表或中间结果 | JOIN 可通过嵌套循环/哈希/排序优化  |
| **可读性**   | 层级结构清晰但不易优化         | 多表连接语义清晰，优化潜力更大     |
| **场景适配** | 适合返回单值、过滤子集         | 适合多表联合查询、复杂条件匹配     |

**子查询效率低的常见原因：**

1. **嵌套执行，缺乏优化**
    - 特别是 **相关子查询（correlated subquery）**，每执行一行都要跑一次子查询，性能非常差
2. **不能使用索引优化**
    - 有些写法（如 `IN (SELECT ...)`）在旧版本 MySQL 中无法有效使用索引
3. **生成临时表/物化结果**
    - 子查询结果需先生成中间表，再参与外层查询，增加 IO 成本



## 10-8-如何优化过多join查询关联

- 适当使用冗余字段减少多表关联查询
- 驱动表和被驱动表（小表join大表）
- 业务允许的话 尽量使用inner join 让系统帮忙自动选择驱动表
- 关联字段一定创建索引
- 调整JOIN BUFFER大小
